// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vertex.proto

#include "vertex.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace generated {
PROTOBUF_CONSTEXPR vertex_3d::vertex_3d(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct vertex_3dDefaultTypeInternal {
  PROTOBUF_CONSTEXPR vertex_3dDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~vertex_3dDefaultTypeInternal() {}
  union {
    vertex_3d _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 vertex_3dDefaultTypeInternal _vertex_3d_default_instance_;
PROTOBUF_CONSTEXPR Rotation_3d::Rotation_3d(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.roll_)*/0
  , /*decltype(_impl_.pitch_)*/0
  , /*decltype(_impl_.yaw_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Rotation_3dDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Rotation_3dDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Rotation_3dDefaultTypeInternal() {}
  union {
    Rotation_3d _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Rotation_3dDefaultTypeInternal _Rotation_3d_default_instance_;
PROTOBUF_CONSTEXPR index_3d::index_3d(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0u
  , /*decltype(_impl_.y_)*/0u
  , /*decltype(_impl_.z_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct index_3dDefaultTypeInternal {
  PROTOBUF_CONSTEXPR index_3dDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~index_3dDefaultTypeInternal() {}
  union {
    index_3d _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 index_3dDefaultTypeInternal _index_3d_default_instance_;
PROTOBUF_CONSTEXPR quaternion::quaternion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.w_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct quaternionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR quaternionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~quaternionDefaultTypeInternal() {}
  union {
    quaternion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 quaternionDefaultTypeInternal _quaternion_default_instance_;
PROTOBUF_CONSTEXPR size_3d::size_3d(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct size_3dDefaultTypeInternal {
  PROTOBUF_CONSTEXPR size_3dDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~size_3dDefaultTypeInternal() {}
  union {
    size_3d _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 size_3dDefaultTypeInternal _size_3d_default_instance_;
PROTOBUF_CONSTEXPR vertex_4d::vertex_4d(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v3d_)*/nullptr
  , /*decltype(_impl_.w_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct vertex_4dDefaultTypeInternal {
  PROTOBUF_CONSTEXPR vertex_4dDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~vertex_4dDefaultTypeInternal() {}
  union {
    vertex_4d _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 vertex_4dDefaultTypeInternal _vertex_4d_default_instance_;
PROTOBUF_CONSTEXPR color::color(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.r_)*/0u
  , /*decltype(_impl_.g_)*/0u
  , /*decltype(_impl_.b_)*/0u
  , /*decltype(_impl_.a_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct colorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR colorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~colorDefaultTypeInternal() {}
  union {
    color _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 colorDefaultTypeInternal _color_default_instance_;
PROTOBUF_CONSTEXPR Matrix::Matrix(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_.rows_)*/0u
  , /*decltype(_impl_.cols_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MatrixDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MatrixDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MatrixDefaultTypeInternal() {}
  union {
    Matrix _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MatrixDefaultTypeInternal _Matrix_default_instance_;
PROTOBUF_CONSTEXPR vertex_3d_array::vertex_3d_array(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vertices_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct vertex_3d_arrayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR vertex_3d_arrayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~vertex_3d_arrayDefaultTypeInternal() {}
  union {
    vertex_3d_array _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 vertex_3d_arrayDefaultTypeInternal _vertex_3d_array_default_instance_;
PROTOBUF_CONSTEXPR vertex_4d_array::vertex_4d_array(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vertices_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct vertex_4d_arrayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR vertex_4d_arrayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~vertex_4d_arrayDefaultTypeInternal() {}
  union {
    vertex_4d_array _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 vertex_4d_arrayDefaultTypeInternal _vertex_4d_array_default_instance_;
PROTOBUF_CONSTEXPR color_array::color_array(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.colors_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct color_arrayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR color_arrayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~color_arrayDefaultTypeInternal() {}
  union {
    color_array _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 color_arrayDefaultTypeInternal _color_array_default_instance_;
PROTOBUF_CONSTEXPR Mesh_Data::Mesh_Data(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vertices_)*/{}
  , /*decltype(_impl_.indices_)*/{}
  , /*decltype(_impl_._indices_cached_byte_size_)*/{0}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.vertex_normals_)*/nullptr
  , /*decltype(_impl_.vertex_colors_)*/nullptr} {}
struct Mesh_DataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Mesh_DataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Mesh_DataDefaultTypeInternal() {}
  union {
    Mesh_Data _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Mesh_DataDefaultTypeInternal _Mesh_Data_default_instance_;
PROTOBUF_CONSTEXPR aabb::aabb(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.diagonal_)*/nullptr
  , /*decltype(_impl_.translation_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct aabbDefaultTypeInternal {
  PROTOBUF_CONSTEXPR aabbDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~aabbDefaultTypeInternal() {}
  union {
    aabb _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 aabbDefaultTypeInternal _aabb_default_instance_;
PROTOBUF_CONSTEXPR obb::obb(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.axis_aligned_)*/nullptr
  , /*decltype(_impl_.rotation_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct obbDefaultTypeInternal {
  PROTOBUF_CONSTEXPR obbDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~obbDefaultTypeInternal() {}
  union {
    obb _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 obbDefaultTypeInternal _obb_default_instance_;
PROTOBUF_CONSTEXPR named_request::named_request(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct named_requestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR named_requestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~named_requestDefaultTypeInternal() {}
  union {
    named_request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 named_requestDefaultTypeInternal _named_request_default_instance_;
PROTOBUF_CONSTEXPR Matrix_TF_Meta::Matrix_TF_Meta(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.matrix_)*/nullptr
  , /*decltype(_impl_.transformation_meta_)*/nullptr} {}
struct Matrix_TF_MetaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Matrix_TF_MetaDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Matrix_TF_MetaDefaultTypeInternal() {}
  union {
    Matrix_TF_Meta _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Matrix_TF_MetaDefaultTypeInternal _Matrix_TF_Meta_default_instance_;
PROTOBUF_CONSTEXPR Mesh_Data_TF_Meta::Mesh_Data_TF_Meta(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mesh_data_)*/nullptr
  , /*decltype(_impl_.transformation_meta_)*/nullptr} {}
struct Mesh_Data_TF_MetaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Mesh_Data_TF_MetaDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Mesh_Data_TF_MetaDefaultTypeInternal() {}
  union {
    Mesh_Data_TF_Meta _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Mesh_Data_TF_MetaDefaultTypeInternal _Mesh_Data_TF_Meta_default_instance_;
PROTOBUF_CONSTEXPR Vertex_3D_Meta::Vertex_3D_Meta(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vertex_)*/nullptr
  , /*decltype(_impl_.transformation_meta_)*/nullptr} {}
struct Vertex_3D_MetaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Vertex_3D_MetaDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Vertex_3D_MetaDefaultTypeInternal() {}
  union {
    Vertex_3D_Meta _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Vertex_3D_MetaDefaultTypeInternal _Vertex_3D_Meta_default_instance_;
}  // namespace generated
namespace generated {

// ===================================================================

class vertex_3d::_Internal {
 public:
};

vertex_3d::vertex_3d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.vertex_3d)
}
vertex_3d::vertex_3d(const vertex_3d& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  vertex_3d* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:generated.vertex_3d)
}

inline void vertex_3d::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

vertex_3d::~vertex_3d() {
  // @@protoc_insertion_point(destructor:generated.vertex_3d)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void vertex_3d::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void vertex_3d::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void vertex_3d::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.vertex_3d)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<std::string>();
}

const char* vertex_3d::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* vertex_3d::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.vertex_3d)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.vertex_3d)
  return target;
}

size_t vertex_3d::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.vertex_3d)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void vertex_3d::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const vertex_3d*>(
      &from));
}

void vertex_3d::MergeFrom(const vertex_3d& from) {
  vertex_3d* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.vertex_3d)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void vertex_3d::CopyFrom(const vertex_3d& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.vertex_3d)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool vertex_3d::IsInitialized() const {
  return true;
}

void vertex_3d::InternalSwap(vertex_3d* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(vertex_3d, _impl_.z_)
      + sizeof(vertex_3d::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(vertex_3d, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

std::string vertex_3d::GetTypeName() const {
  return "generated.vertex_3d";
}


// ===================================================================

class Rotation_3d::_Internal {
 public:
};

Rotation_3d::Rotation_3d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.Rotation_3d)
}
Rotation_3d::Rotation_3d(const Rotation_3d& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Rotation_3d* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.roll_){}
    , decltype(_impl_.pitch_){}
    , decltype(_impl_.yaw_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.roll_, &from._impl_.roll_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.yaw_) -
    reinterpret_cast<char*>(&_impl_.roll_)) + sizeof(_impl_.yaw_));
  // @@protoc_insertion_point(copy_constructor:generated.Rotation_3d)
}

inline void Rotation_3d::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.roll_){0}
    , decltype(_impl_.pitch_){0}
    , decltype(_impl_.yaw_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Rotation_3d::~Rotation_3d() {
  // @@protoc_insertion_point(destructor:generated.Rotation_3d)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Rotation_3d::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Rotation_3d::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Rotation_3d::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.Rotation_3d)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.roll_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.yaw_) -
      reinterpret_cast<char*>(&_impl_.roll_)) + sizeof(_impl_.yaw_));
  _internal_metadata_.Clear<std::string>();
}

const char* Rotation_3d::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float roll = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.roll_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float pitch = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.pitch_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float yaw = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.yaw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Rotation_3d::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.Rotation_3d)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float roll = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_roll = this->_internal_roll();
  uint32_t raw_roll;
  memcpy(&raw_roll, &tmp_roll, sizeof(tmp_roll));
  if (raw_roll != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_roll(), target);
  }

  // float pitch = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch = this->_internal_pitch();
  uint32_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_pitch(), target);
  }

  // float yaw = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_yaw = this->_internal_yaw();
  uint32_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_yaw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.Rotation_3d)
  return target;
}

size_t Rotation_3d::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.Rotation_3d)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float roll = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_roll = this->_internal_roll();
  uint32_t raw_roll;
  memcpy(&raw_roll, &tmp_roll, sizeof(tmp_roll));
  if (raw_roll != 0) {
    total_size += 1 + 4;
  }

  // float pitch = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch = this->_internal_pitch();
  uint32_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    total_size += 1 + 4;
  }

  // float yaw = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_yaw = this->_internal_yaw();
  uint32_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Rotation_3d::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Rotation_3d*>(
      &from));
}

void Rotation_3d::MergeFrom(const Rotation_3d& from) {
  Rotation_3d* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.Rotation_3d)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_roll = from._internal_roll();
  uint32_t raw_roll;
  memcpy(&raw_roll, &tmp_roll, sizeof(tmp_roll));
  if (raw_roll != 0) {
    _this->_internal_set_roll(from._internal_roll());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch = from._internal_pitch();
  uint32_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    _this->_internal_set_pitch(from._internal_pitch());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_yaw = from._internal_yaw();
  uint32_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    _this->_internal_set_yaw(from._internal_yaw());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Rotation_3d::CopyFrom(const Rotation_3d& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.Rotation_3d)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Rotation_3d::IsInitialized() const {
  return true;
}

void Rotation_3d::InternalSwap(Rotation_3d* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Rotation_3d, _impl_.yaw_)
      + sizeof(Rotation_3d::_impl_.yaw_)
      - PROTOBUF_FIELD_OFFSET(Rotation_3d, _impl_.roll_)>(
          reinterpret_cast<char*>(&_impl_.roll_),
          reinterpret_cast<char*>(&other->_impl_.roll_));
}

std::string Rotation_3d::GetTypeName() const {
  return "generated.Rotation_3d";
}


// ===================================================================

class index_3d::_Internal {
 public:
};

index_3d::index_3d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.index_3d)
}
index_3d::index_3d(const index_3d& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  index_3d* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:generated.index_3d)
}

inline void index_3d::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0u}
    , decltype(_impl_.y_){0u}
    , decltype(_impl_.z_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

index_3d::~index_3d() {
  // @@protoc_insertion_point(destructor:generated.index_3d)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void index_3d::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void index_3d::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void index_3d::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.index_3d)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<std::string>();
}

const char* index_3d::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* index_3d::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.index_3d)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 x = 1;
  if (this->_internal_x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_x(), target);
  }

  // uint32 y = 2;
  if (this->_internal_y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_y(), target);
  }

  // uint32 z = 3;
  if (this->_internal_z() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.index_3d)
  return target;
}

size_t index_3d::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.index_3d)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 x = 1;
  if (this->_internal_x() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_x());
  }

  // uint32 y = 2;
  if (this->_internal_y() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_y());
  }

  // uint32 z = 3;
  if (this->_internal_z() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_z());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void index_3d::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const index_3d*>(
      &from));
}

void index_3d::MergeFrom(const index_3d& from) {
  index_3d* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.index_3d)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_x() != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  if (from._internal_y() != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  if (from._internal_z() != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void index_3d::CopyFrom(const index_3d& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.index_3d)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool index_3d::IsInitialized() const {
  return true;
}

void index_3d::InternalSwap(index_3d* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(index_3d, _impl_.z_)
      + sizeof(index_3d::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(index_3d, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

std::string index_3d::GetTypeName() const {
  return "generated.index_3d";
}


// ===================================================================

class quaternion::_Internal {
 public:
};

quaternion::quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.quaternion)
}
quaternion::quaternion(const quaternion& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  quaternion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.w_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.w_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.w_));
  // @@protoc_insertion_point(copy_constructor:generated.quaternion)
}

inline void quaternion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.w_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

quaternion::~quaternion() {
  // @@protoc_insertion_point(destructor:generated.quaternion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void quaternion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void quaternion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.quaternion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.w_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.w_));
  _internal_metadata_.Clear<std::string>();
}

const char* quaternion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float w = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* quaternion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.quaternion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  // float w = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_w(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.quaternion)
  return target;
}

size_t quaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.quaternion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 4;
  }

  // float w = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void quaternion::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const quaternion*>(
      &from));
}

void quaternion::MergeFrom(const quaternion& from) {
  quaternion* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.quaternion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = from._internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    _this->_internal_set_w(from._internal_w());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void quaternion::CopyFrom(const quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool quaternion::IsInitialized() const {
  return true;
}

void quaternion::InternalSwap(quaternion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(quaternion, _impl_.w_)
      + sizeof(quaternion::_impl_.w_)
      - PROTOBUF_FIELD_OFFSET(quaternion, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

std::string quaternion::GetTypeName() const {
  return "generated.quaternion";
}


// ===================================================================

class size_3d::_Internal {
 public:
};

size_3d::size_3d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.size_3d)
}
size_3d::size_3d(const size_3d& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  size_3d* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:generated.size_3d)
}

inline void size_3d::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

size_3d::~size_3d() {
  // @@protoc_insertion_point(destructor:generated.size_3d)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void size_3d::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void size_3d::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void size_3d::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.size_3d)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<std::string>();
}

const char* size_3d::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* size_3d::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.size_3d)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.size_3d)
  return target;
}

size_t size_3d::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.size_3d)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void size_3d::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const size_3d*>(
      &from));
}

void size_3d::MergeFrom(const size_3d& from) {
  size_3d* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.size_3d)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void size_3d::CopyFrom(const size_3d& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.size_3d)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool size_3d::IsInitialized() const {
  return true;
}

void size_3d::InternalSwap(size_3d* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(size_3d, _impl_.z_)
      + sizeof(size_3d::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(size_3d, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

std::string size_3d::GetTypeName() const {
  return "generated.size_3d";
}


// ===================================================================

class vertex_4d::_Internal {
 public:
  static const ::generated::vertex_3d& v3d(const vertex_4d* msg);
};

const ::generated::vertex_3d&
vertex_4d::_Internal::v3d(const vertex_4d* msg) {
  return *msg->_impl_.v3d_;
}
vertex_4d::vertex_4d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.vertex_4d)
}
vertex_4d::vertex_4d(const vertex_4d& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  vertex_4d* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.v3d_){nullptr}
    , decltype(_impl_.w_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_v3d()) {
    _this->_impl_.v3d_ = new ::generated::vertex_3d(*from._impl_.v3d_);
  }
  _this->_impl_.w_ = from._impl_.w_;
  // @@protoc_insertion_point(copy_constructor:generated.vertex_4d)
}

inline void vertex_4d::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.v3d_){nullptr}
    , decltype(_impl_.w_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

vertex_4d::~vertex_4d() {
  // @@protoc_insertion_point(destructor:generated.vertex_4d)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void vertex_4d::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.v3d_;
}

void vertex_4d::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void vertex_4d::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.vertex_4d)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.v3d_ != nullptr) {
    delete _impl_.v3d_;
  }
  _impl_.v3d_ = nullptr;
  _impl_.w_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* vertex_4d::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .generated.vertex_3d v3D = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_v3d(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float w = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* vertex_4d::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.vertex_4d)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .generated.vertex_3d v3D = 1;
  if (this->_internal_has_v3d()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::v3d(this),
        _Internal::v3d(this).GetCachedSize(), target, stream);
  }

  // float w = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_w(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.vertex_4d)
  return target;
}

size_t vertex_4d::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.vertex_4d)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .generated.vertex_3d v3D = 1;
  if (this->_internal_has_v3d()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.v3d_);
  }

  // float w = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void vertex_4d::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const vertex_4d*>(
      &from));
}

void vertex_4d::MergeFrom(const vertex_4d& from) {
  vertex_4d* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.vertex_4d)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_v3d()) {
    _this->_internal_mutable_v3d()->::generated::vertex_3d::MergeFrom(
        from._internal_v3d());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = from._internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    _this->_internal_set_w(from._internal_w());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void vertex_4d::CopyFrom(const vertex_4d& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.vertex_4d)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool vertex_4d::IsInitialized() const {
  return true;
}

void vertex_4d::InternalSwap(vertex_4d* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(vertex_4d, _impl_.w_)
      + sizeof(vertex_4d::_impl_.w_)
      - PROTOBUF_FIELD_OFFSET(vertex_4d, _impl_.v3d_)>(
          reinterpret_cast<char*>(&_impl_.v3d_),
          reinterpret_cast<char*>(&other->_impl_.v3d_));
}

std::string vertex_4d::GetTypeName() const {
  return "generated.vertex_4d";
}


// ===================================================================

class color::_Internal {
 public:
};

color::color(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.color)
}
color::color(const color& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  color* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.r_){}
    , decltype(_impl_.g_){}
    , decltype(_impl_.b_){}
    , decltype(_impl_.a_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.r_, &from._impl_.r_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.a_) -
    reinterpret_cast<char*>(&_impl_.r_)) + sizeof(_impl_.a_));
  // @@protoc_insertion_point(copy_constructor:generated.color)
}

inline void color::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.r_){0u}
    , decltype(_impl_.g_){0u}
    , decltype(_impl_.b_){0u}
    , decltype(_impl_.a_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

color::~color() {
  // @@protoc_insertion_point(destructor:generated.color)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void color::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void color::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void color::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.color)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.r_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.a_) -
      reinterpret_cast<char*>(&_impl_.r_)) + sizeof(_impl_.a_));
  _internal_metadata_.Clear<std::string>();
}

const char* color::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 r = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.r_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 g = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.g_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 b = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.b_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 a = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.a_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* color::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.color)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 r = 1;
  if (this->_internal_r() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_r(), target);
  }

  // uint32 g = 2;
  if (this->_internal_g() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_g(), target);
  }

  // uint32 b = 3;
  if (this->_internal_b() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_b(), target);
  }

  // uint32 a = 4;
  if (this->_internal_a() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_a(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.color)
  return target;
}

size_t color::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.color)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 r = 1;
  if (this->_internal_r() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_r());
  }

  // uint32 g = 2;
  if (this->_internal_g() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_g());
  }

  // uint32 b = 3;
  if (this->_internal_b() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_b());
  }

  // uint32 a = 4;
  if (this->_internal_a() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_a());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void color::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const color*>(
      &from));
}

void color::MergeFrom(const color& from) {
  color* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.color)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_r() != 0) {
    _this->_internal_set_r(from._internal_r());
  }
  if (from._internal_g() != 0) {
    _this->_internal_set_g(from._internal_g());
  }
  if (from._internal_b() != 0) {
    _this->_internal_set_b(from._internal_b());
  }
  if (from._internal_a() != 0) {
    _this->_internal_set_a(from._internal_a());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void color::CopyFrom(const color& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.color)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool color::IsInitialized() const {
  return true;
}

void color::InternalSwap(color* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(color, _impl_.a_)
      + sizeof(color::_impl_.a_)
      - PROTOBUF_FIELD_OFFSET(color, _impl_.r_)>(
          reinterpret_cast<char*>(&_impl_.r_),
          reinterpret_cast<char*>(&other->_impl_.r_));
}

std::string color::GetTypeName() const {
  return "generated.color";
}


// ===================================================================

class Matrix::_Internal {
 public:
};

Matrix::Matrix(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.Matrix)
}
Matrix::Matrix(const Matrix& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Matrix* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){from._impl_.data_}
    , decltype(_impl_.rows_){}
    , decltype(_impl_.cols_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.rows_, &from._impl_.rows_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cols_) -
    reinterpret_cast<char*>(&_impl_.rows_)) + sizeof(_impl_.cols_));
  // @@protoc_insertion_point(copy_constructor:generated.Matrix)
}

inline void Matrix::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){arena}
    , decltype(_impl_.rows_){0u}
    , decltype(_impl_.cols_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Matrix::~Matrix() {
  // @@protoc_insertion_point(destructor:generated.Matrix)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Matrix::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.~RepeatedField();
}

void Matrix::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Matrix::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.Matrix)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.Clear();
  ::memset(&_impl_.rows_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.cols_) -
      reinterpret_cast<char*>(&_impl_.rows_)) + sizeof(_impl_.cols_));
  _internal_metadata_.Clear<std::string>();
}

const char* Matrix::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 rows = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 cols = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.cols_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float data = 3 [packed = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 29) {
          _internal_add_data(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Matrix::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.Matrix)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 rows = 1;
  if (this->_internal_rows() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_rows(), target);
  }

  // uint32 cols = 2;
  if (this->_internal_cols() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_cols(), target);
  }

  // repeated float data = 3 [packed = true];
  if (this->_internal_data_size() > 0) {
    target = stream->WriteFixedPacked(3, _internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.Matrix)
  return target;
}

size_t Matrix::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.Matrix)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float data = 3 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_data_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // uint32 rows = 1;
  if (this->_internal_rows() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rows());
  }

  // uint32 cols = 2;
  if (this->_internal_cols() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cols());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Matrix::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Matrix*>(
      &from));
}

void Matrix::MergeFrom(const Matrix& from) {
  Matrix* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.Matrix)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.data_.MergeFrom(from._impl_.data_);
  if (from._internal_rows() != 0) {
    _this->_internal_set_rows(from._internal_rows());
  }
  if (from._internal_cols() != 0) {
    _this->_internal_set_cols(from._internal_cols());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Matrix::CopyFrom(const Matrix& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.Matrix)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Matrix::IsInitialized() const {
  return true;
}

void Matrix::InternalSwap(Matrix* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.data_.InternalSwap(&other->_impl_.data_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Matrix, _impl_.cols_)
      + sizeof(Matrix::_impl_.cols_)
      - PROTOBUF_FIELD_OFFSET(Matrix, _impl_.rows_)>(
          reinterpret_cast<char*>(&_impl_.rows_),
          reinterpret_cast<char*>(&other->_impl_.rows_));
}

std::string Matrix::GetTypeName() const {
  return "generated.Matrix";
}


// ===================================================================

class vertex_3d_array::_Internal {
 public:
};

vertex_3d_array::vertex_3d_array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.vertex_3d_array)
}
vertex_3d_array::vertex_3d_array(const vertex_3d_array& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  vertex_3d_array* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vertices_){from._impl_.vertices_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:generated.vertex_3d_array)
}

inline void vertex_3d_array::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vertices_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

vertex_3d_array::~vertex_3d_array() {
  // @@protoc_insertion_point(destructor:generated.vertex_3d_array)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void vertex_3d_array::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vertices_.~RepeatedPtrField();
}

void vertex_3d_array::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void vertex_3d_array::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.vertex_3d_array)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vertices_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* vertex_3d_array::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .generated.vertex_3d vertices = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_vertices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* vertex_3d_array::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.vertex_3d_array)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .generated.vertex_3d vertices = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_vertices_size()); i < n; i++) {
    const auto& repfield = this->_internal_vertices(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.vertex_3d_array)
  return target;
}

size_t vertex_3d_array::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.vertex_3d_array)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .generated.vertex_3d vertices = 1;
  total_size += 1UL * this->_internal_vertices_size();
  for (const auto& msg : this->_impl_.vertices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void vertex_3d_array::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const vertex_3d_array*>(
      &from));
}

void vertex_3d_array::MergeFrom(const vertex_3d_array& from) {
  vertex_3d_array* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.vertex_3d_array)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.vertices_.MergeFrom(from._impl_.vertices_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void vertex_3d_array::CopyFrom(const vertex_3d_array& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.vertex_3d_array)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool vertex_3d_array::IsInitialized() const {
  return true;
}

void vertex_3d_array::InternalSwap(vertex_3d_array* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.vertices_.InternalSwap(&other->_impl_.vertices_);
}

std::string vertex_3d_array::GetTypeName() const {
  return "generated.vertex_3d_array";
}


// ===================================================================

class vertex_4d_array::_Internal {
 public:
};

vertex_4d_array::vertex_4d_array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.vertex_4d_array)
}
vertex_4d_array::vertex_4d_array(const vertex_4d_array& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  vertex_4d_array* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vertices_){from._impl_.vertices_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:generated.vertex_4d_array)
}

inline void vertex_4d_array::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vertices_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

vertex_4d_array::~vertex_4d_array() {
  // @@protoc_insertion_point(destructor:generated.vertex_4d_array)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void vertex_4d_array::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vertices_.~RepeatedPtrField();
}

void vertex_4d_array::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void vertex_4d_array::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.vertex_4d_array)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vertices_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* vertex_4d_array::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .generated.vertex_4d vertices = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_vertices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* vertex_4d_array::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.vertex_4d_array)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .generated.vertex_4d vertices = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_vertices_size()); i < n; i++) {
    const auto& repfield = this->_internal_vertices(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.vertex_4d_array)
  return target;
}

size_t vertex_4d_array::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.vertex_4d_array)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .generated.vertex_4d vertices = 1;
  total_size += 1UL * this->_internal_vertices_size();
  for (const auto& msg : this->_impl_.vertices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void vertex_4d_array::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const vertex_4d_array*>(
      &from));
}

void vertex_4d_array::MergeFrom(const vertex_4d_array& from) {
  vertex_4d_array* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.vertex_4d_array)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.vertices_.MergeFrom(from._impl_.vertices_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void vertex_4d_array::CopyFrom(const vertex_4d_array& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.vertex_4d_array)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool vertex_4d_array::IsInitialized() const {
  return true;
}

void vertex_4d_array::InternalSwap(vertex_4d_array* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.vertices_.InternalSwap(&other->_impl_.vertices_);
}

std::string vertex_4d_array::GetTypeName() const {
  return "generated.vertex_4d_array";
}


// ===================================================================

class color_array::_Internal {
 public:
};

color_array::color_array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.color_array)
}
color_array::color_array(const color_array& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  color_array* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.colors_){from._impl_.colors_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:generated.color_array)
}

inline void color_array::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.colors_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

color_array::~color_array() {
  // @@protoc_insertion_point(destructor:generated.color_array)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void color_array::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.colors_.~RepeatedPtrField();
}

void color_array::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void color_array::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.color_array)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.colors_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* color_array::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .generated.color colors = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_colors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* color_array::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.color_array)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .generated.color colors = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_colors_size()); i < n; i++) {
    const auto& repfield = this->_internal_colors(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.color_array)
  return target;
}

size_t color_array::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.color_array)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .generated.color colors = 1;
  total_size += 1UL * this->_internal_colors_size();
  for (const auto& msg : this->_impl_.colors_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void color_array::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const color_array*>(
      &from));
}

void color_array::MergeFrom(const color_array& from) {
  color_array* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.color_array)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.colors_.MergeFrom(from._impl_.colors_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void color_array::CopyFrom(const color_array& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.color_array)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool color_array::IsInitialized() const {
  return true;
}

void color_array::InternalSwap(color_array* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.colors_.InternalSwap(&other->_impl_.colors_);
}

std::string color_array::GetTypeName() const {
  return "generated.color_array";
}


// ===================================================================

class Mesh_Data::_Internal {
 public:
  using HasBits = decltype(std::declval<Mesh_Data>()._impl_._has_bits_);
  static const ::generated::vertex_3d_array& vertex_normals(const Mesh_Data* msg);
  static void set_has_vertex_normals(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::generated::color_array& vertex_colors(const Mesh_Data* msg);
  static void set_has_vertex_colors(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::generated::vertex_3d_array&
Mesh_Data::_Internal::vertex_normals(const Mesh_Data* msg) {
  return *msg->_impl_.vertex_normals_;
}
const ::generated::color_array&
Mesh_Data::_Internal::vertex_colors(const Mesh_Data* msg) {
  return *msg->_impl_.vertex_colors_;
}
Mesh_Data::Mesh_Data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.Mesh_Data)
}
Mesh_Data::Mesh_Data(const Mesh_Data& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Mesh_Data* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vertices_){from._impl_.vertices_}
    , decltype(_impl_.indices_){from._impl_.indices_}
    , /*decltype(_impl_._indices_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , decltype(_impl_.vertex_normals_){nullptr}
    , decltype(_impl_.vertex_colors_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_vertex_normals()) {
    _this->_impl_.vertex_normals_ = new ::generated::vertex_3d_array(*from._impl_.vertex_normals_);
  }
  if (from._internal_has_vertex_colors()) {
    _this->_impl_.vertex_colors_ = new ::generated::color_array(*from._impl_.vertex_colors_);
  }
  // @@protoc_insertion_point(copy_constructor:generated.Mesh_Data)
}

inline void Mesh_Data::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vertices_){arena}
    , decltype(_impl_.indices_){arena}
    , /*decltype(_impl_._indices_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , decltype(_impl_.vertex_normals_){nullptr}
    , decltype(_impl_.vertex_colors_){nullptr}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Mesh_Data::~Mesh_Data() {
  // @@protoc_insertion_point(destructor:generated.Mesh_Data)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Mesh_Data::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vertices_.~RepeatedPtrField();
  _impl_.indices_.~RepeatedField();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.vertex_normals_;
  if (this != internal_default_instance()) delete _impl_.vertex_colors_;
}

void Mesh_Data::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Mesh_Data::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.Mesh_Data)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vertices_.Clear();
  _impl_.indices_.Clear();
  _impl_.name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.vertex_normals_ != nullptr);
      _impl_.vertex_normals_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.vertex_colors_ != nullptr);
      _impl_.vertex_colors_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Mesh_Data::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .generated.vertex_3d vertices = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_vertices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 indices = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_indices(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_indices(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // optional .generated.vertex_3d_array vertex_normals = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_vertex_normals(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .generated.color_array vertex_colors = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_vertex_colors(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Mesh_Data::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.Mesh_Data)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .generated.vertex_3d vertices = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_vertices_size()); i < n; i++) {
    const auto& repfield = this->_internal_vertices(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated uint32 indices = 2;
  {
    int byte_size = _impl_._indices_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          2, _internal_indices(), byte_size, target);
    }
  }

  // string name = 3;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "generated.Mesh_Data.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional .generated.vertex_3d_array vertex_normals = 4;
  if (_internal_has_vertex_normals()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::vertex_normals(this),
        _Internal::vertex_normals(this).GetCachedSize(), target, stream);
  }

  // optional .generated.color_array vertex_colors = 5;
  if (_internal_has_vertex_colors()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::vertex_colors(this),
        _Internal::vertex_colors(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.Mesh_Data)
  return target;
}

size_t Mesh_Data::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.Mesh_Data)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .generated.vertex_3d vertices = 1;
  total_size += 1UL * this->_internal_vertices_size();
  for (const auto& msg : this->_impl_.vertices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 indices = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.indices_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._indices_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string name = 3;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .generated.vertex_3d_array vertex_normals = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vertex_normals_);
    }

    // optional .generated.color_array vertex_colors = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vertex_colors_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Mesh_Data::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Mesh_Data*>(
      &from));
}

void Mesh_Data::MergeFrom(const Mesh_Data& from) {
  Mesh_Data* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.Mesh_Data)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.vertices_.MergeFrom(from._impl_.vertices_);
  _this->_impl_.indices_.MergeFrom(from._impl_.indices_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_vertex_normals()->::generated::vertex_3d_array::MergeFrom(
          from._internal_vertex_normals());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_vertex_colors()->::generated::color_array::MergeFrom(
          from._internal_vertex_colors());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Mesh_Data::CopyFrom(const Mesh_Data& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.Mesh_Data)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Mesh_Data::IsInitialized() const {
  return true;
}

void Mesh_Data::InternalSwap(Mesh_Data* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.vertices_.InternalSwap(&other->_impl_.vertices_);
  _impl_.indices_.InternalSwap(&other->_impl_.indices_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Mesh_Data, _impl_.vertex_colors_)
      + sizeof(Mesh_Data::_impl_.vertex_colors_)
      - PROTOBUF_FIELD_OFFSET(Mesh_Data, _impl_.vertex_normals_)>(
          reinterpret_cast<char*>(&_impl_.vertex_normals_),
          reinterpret_cast<char*>(&other->_impl_.vertex_normals_));
}

std::string Mesh_Data::GetTypeName() const {
  return "generated.Mesh_Data";
}


// ===================================================================

class aabb::_Internal {
 public:
  static const ::generated::size_3d& diagonal(const aabb* msg);
  static const ::generated::vertex_3d& translation(const aabb* msg);
};

const ::generated::size_3d&
aabb::_Internal::diagonal(const aabb* msg) {
  return *msg->_impl_.diagonal_;
}
const ::generated::vertex_3d&
aabb::_Internal::translation(const aabb* msg) {
  return *msg->_impl_.translation_;
}
aabb::aabb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.aabb)
}
aabb::aabb(const aabb& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  aabb* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.diagonal_){nullptr}
    , decltype(_impl_.translation_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_diagonal()) {
    _this->_impl_.diagonal_ = new ::generated::size_3d(*from._impl_.diagonal_);
  }
  if (from._internal_has_translation()) {
    _this->_impl_.translation_ = new ::generated::vertex_3d(*from._impl_.translation_);
  }
  // @@protoc_insertion_point(copy_constructor:generated.aabb)
}

inline void aabb::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.diagonal_){nullptr}
    , decltype(_impl_.translation_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

aabb::~aabb() {
  // @@protoc_insertion_point(destructor:generated.aabb)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void aabb::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.diagonal_;
  if (this != internal_default_instance()) delete _impl_.translation_;
}

void aabb::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void aabb::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.aabb)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.diagonal_ != nullptr) {
    delete _impl_.diagonal_;
  }
  _impl_.diagonal_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.translation_ != nullptr) {
    delete _impl_.translation_;
  }
  _impl_.translation_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* aabb::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .generated.size_3d diagonal = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_diagonal(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .generated.vertex_3d translation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_translation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* aabb::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.aabb)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .generated.size_3d diagonal = 1;
  if (this->_internal_has_diagonal()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::diagonal(this),
        _Internal::diagonal(this).GetCachedSize(), target, stream);
  }

  // .generated.vertex_3d translation = 2;
  if (this->_internal_has_translation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::translation(this),
        _Internal::translation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.aabb)
  return target;
}

size_t aabb::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.aabb)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .generated.size_3d diagonal = 1;
  if (this->_internal_has_diagonal()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.diagonal_);
  }

  // .generated.vertex_3d translation = 2;
  if (this->_internal_has_translation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.translation_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void aabb::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const aabb*>(
      &from));
}

void aabb::MergeFrom(const aabb& from) {
  aabb* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.aabb)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_diagonal()) {
    _this->_internal_mutable_diagonal()->::generated::size_3d::MergeFrom(
        from._internal_diagonal());
  }
  if (from._internal_has_translation()) {
    _this->_internal_mutable_translation()->::generated::vertex_3d::MergeFrom(
        from._internal_translation());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void aabb::CopyFrom(const aabb& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.aabb)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool aabb::IsInitialized() const {
  return true;
}

void aabb::InternalSwap(aabb* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(aabb, _impl_.translation_)
      + sizeof(aabb::_impl_.translation_)
      - PROTOBUF_FIELD_OFFSET(aabb, _impl_.diagonal_)>(
          reinterpret_cast<char*>(&_impl_.diagonal_),
          reinterpret_cast<char*>(&other->_impl_.diagonal_));
}

std::string aabb::GetTypeName() const {
  return "generated.aabb";
}


// ===================================================================

class obb::_Internal {
 public:
  static const ::generated::aabb& axis_aligned(const obb* msg);
  static const ::generated::quaternion& rotation(const obb* msg);
};

const ::generated::aabb&
obb::_Internal::axis_aligned(const obb* msg) {
  return *msg->_impl_.axis_aligned_;
}
const ::generated::quaternion&
obb::_Internal::rotation(const obb* msg) {
  return *msg->_impl_.rotation_;
}
obb::obb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.obb)
}
obb::obb(const obb& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  obb* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.axis_aligned_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_axis_aligned()) {
    _this->_impl_.axis_aligned_ = new ::generated::aabb(*from._impl_.axis_aligned_);
  }
  if (from._internal_has_rotation()) {
    _this->_impl_.rotation_ = new ::generated::quaternion(*from._impl_.rotation_);
  }
  // @@protoc_insertion_point(copy_constructor:generated.obb)
}

inline void obb::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.axis_aligned_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

obb::~obb() {
  // @@protoc_insertion_point(destructor:generated.obb)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void obb::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.axis_aligned_;
  if (this != internal_default_instance()) delete _impl_.rotation_;
}

void obb::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void obb::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.obb)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.axis_aligned_ != nullptr) {
    delete _impl_.axis_aligned_;
  }
  _impl_.axis_aligned_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.rotation_ != nullptr) {
    delete _impl_.rotation_;
  }
  _impl_.rotation_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* obb::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .generated.aabb axis_aligned = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_axis_aligned(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .generated.quaternion rotation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* obb::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.obb)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .generated.aabb axis_aligned = 1;
  if (this->_internal_has_axis_aligned()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::axis_aligned(this),
        _Internal::axis_aligned(this).GetCachedSize(), target, stream);
  }

  // .generated.quaternion rotation = 2;
  if (this->_internal_has_rotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rotation(this),
        _Internal::rotation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.obb)
  return target;
}

size_t obb::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.obb)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .generated.aabb axis_aligned = 1;
  if (this->_internal_has_axis_aligned()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.axis_aligned_);
  }

  // .generated.quaternion rotation = 2;
  if (this->_internal_has_rotation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rotation_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void obb::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const obb*>(
      &from));
}

void obb::MergeFrom(const obb& from) {
  obb* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.obb)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_axis_aligned()) {
    _this->_internal_mutable_axis_aligned()->::generated::aabb::MergeFrom(
        from._internal_axis_aligned());
  }
  if (from._internal_has_rotation()) {
    _this->_internal_mutable_rotation()->::generated::quaternion::MergeFrom(
        from._internal_rotation());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void obb::CopyFrom(const obb& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.obb)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool obb::IsInitialized() const {
  return true;
}

void obb::InternalSwap(obb* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(obb, _impl_.rotation_)
      + sizeof(obb::_impl_.rotation_)
      - PROTOBUF_FIELD_OFFSET(obb, _impl_.axis_aligned_)>(
          reinterpret_cast<char*>(&_impl_.axis_aligned_),
          reinterpret_cast<char*>(&other->_impl_.axis_aligned_));
}

std::string obb::GetTypeName() const {
  return "generated.obb";
}


// ===================================================================

class named_request::_Internal {
 public:
};

named_request::named_request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.named_request)
}
named_request::named_request(const named_request& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  named_request* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:generated.named_request)
}

inline void named_request::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

named_request::~named_request() {
  // @@protoc_insertion_point(destructor:generated.named_request)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void named_request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void named_request::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void named_request::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.named_request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* named_request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* named_request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.named_request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "generated.named_request.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.named_request)
  return target;
}

size_t named_request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.named_request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void named_request::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const named_request*>(
      &from));
}

void named_request::MergeFrom(const named_request& from) {
  named_request* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.named_request)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void named_request::CopyFrom(const named_request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.named_request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool named_request::IsInitialized() const {
  return true;
}

void named_request::InternalSwap(named_request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

std::string named_request::GetTypeName() const {
  return "generated.named_request";
}


// ===================================================================

class Matrix_TF_Meta::_Internal {
 public:
  using HasBits = decltype(std::declval<Matrix_TF_Meta>()._impl_._has_bits_);
  static const ::generated::Matrix& matrix(const Matrix_TF_Meta* msg);
  static const ::generated::Transformation_Meta& transformation_meta(const Matrix_TF_Meta* msg);
  static void set_has_transformation_meta(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::generated::Matrix&
Matrix_TF_Meta::_Internal::matrix(const Matrix_TF_Meta* msg) {
  return *msg->_impl_.matrix_;
}
const ::generated::Transformation_Meta&
Matrix_TF_Meta::_Internal::transformation_meta(const Matrix_TF_Meta* msg) {
  return *msg->_impl_.transformation_meta_;
}
void Matrix_TF_Meta::clear_transformation_meta() {
  if (_impl_.transformation_meta_ != nullptr) _impl_.transformation_meta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
Matrix_TF_Meta::Matrix_TF_Meta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.Matrix_TF_Meta)
}
Matrix_TF_Meta::Matrix_TF_Meta(const Matrix_TF_Meta& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Matrix_TF_Meta* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.matrix_){nullptr}
    , decltype(_impl_.transformation_meta_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_matrix()) {
    _this->_impl_.matrix_ = new ::generated::Matrix(*from._impl_.matrix_);
  }
  if (from._internal_has_transformation_meta()) {
    _this->_impl_.transformation_meta_ = new ::generated::Transformation_Meta(*from._impl_.transformation_meta_);
  }
  // @@protoc_insertion_point(copy_constructor:generated.Matrix_TF_Meta)
}

inline void Matrix_TF_Meta::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.matrix_){nullptr}
    , decltype(_impl_.transformation_meta_){nullptr}
  };
}

Matrix_TF_Meta::~Matrix_TF_Meta() {
  // @@protoc_insertion_point(destructor:generated.Matrix_TF_Meta)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Matrix_TF_Meta::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.matrix_;
  if (this != internal_default_instance()) delete _impl_.transformation_meta_;
}

void Matrix_TF_Meta::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Matrix_TF_Meta::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.Matrix_TF_Meta)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.matrix_ != nullptr) {
    delete _impl_.matrix_;
  }
  _impl_.matrix_ = nullptr;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.transformation_meta_ != nullptr);
    _impl_.transformation_meta_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Matrix_TF_Meta::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .generated.Matrix matrix = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_matrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .generated.Transformation_Meta transformation_meta = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_transformation_meta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Matrix_TF_Meta::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.Matrix_TF_Meta)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .generated.Matrix matrix = 1;
  if (this->_internal_has_matrix()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::matrix(this),
        _Internal::matrix(this).GetCachedSize(), target, stream);
  }

  // optional .generated.Transformation_Meta transformation_meta = 2;
  if (_internal_has_transformation_meta()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::transformation_meta(this),
        _Internal::transformation_meta(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.Matrix_TF_Meta)
  return target;
}

size_t Matrix_TF_Meta::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.Matrix_TF_Meta)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .generated.Matrix matrix = 1;
  if (this->_internal_has_matrix()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.matrix_);
  }

  // optional .generated.Transformation_Meta transformation_meta = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.transformation_meta_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Matrix_TF_Meta::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Matrix_TF_Meta*>(
      &from));
}

void Matrix_TF_Meta::MergeFrom(const Matrix_TF_Meta& from) {
  Matrix_TF_Meta* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.Matrix_TF_Meta)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_matrix()) {
    _this->_internal_mutable_matrix()->::generated::Matrix::MergeFrom(
        from._internal_matrix());
  }
  if (from._internal_has_transformation_meta()) {
    _this->_internal_mutable_transformation_meta()->::generated::Transformation_Meta::MergeFrom(
        from._internal_transformation_meta());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Matrix_TF_Meta::CopyFrom(const Matrix_TF_Meta& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.Matrix_TF_Meta)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Matrix_TF_Meta::IsInitialized() const {
  return true;
}

void Matrix_TF_Meta::InternalSwap(Matrix_TF_Meta* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Matrix_TF_Meta, _impl_.transformation_meta_)
      + sizeof(Matrix_TF_Meta::_impl_.transformation_meta_)
      - PROTOBUF_FIELD_OFFSET(Matrix_TF_Meta, _impl_.matrix_)>(
          reinterpret_cast<char*>(&_impl_.matrix_),
          reinterpret_cast<char*>(&other->_impl_.matrix_));
}

std::string Matrix_TF_Meta::GetTypeName() const {
  return "generated.Matrix_TF_Meta";
}


// ===================================================================

class Mesh_Data_TF_Meta::_Internal {
 public:
  using HasBits = decltype(std::declval<Mesh_Data_TF_Meta>()._impl_._has_bits_);
  static const ::generated::Mesh_Data& mesh_data(const Mesh_Data_TF_Meta* msg);
  static const ::generated::Transformation_Meta& transformation_meta(const Mesh_Data_TF_Meta* msg);
  static void set_has_transformation_meta(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::generated::Mesh_Data&
Mesh_Data_TF_Meta::_Internal::mesh_data(const Mesh_Data_TF_Meta* msg) {
  return *msg->_impl_.mesh_data_;
}
const ::generated::Transformation_Meta&
Mesh_Data_TF_Meta::_Internal::transformation_meta(const Mesh_Data_TF_Meta* msg) {
  return *msg->_impl_.transformation_meta_;
}
void Mesh_Data_TF_Meta::clear_transformation_meta() {
  if (_impl_.transformation_meta_ != nullptr) _impl_.transformation_meta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
Mesh_Data_TF_Meta::Mesh_Data_TF_Meta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.Mesh_Data_TF_Meta)
}
Mesh_Data_TF_Meta::Mesh_Data_TF_Meta(const Mesh_Data_TF_Meta& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Mesh_Data_TF_Meta* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mesh_data_){nullptr}
    , decltype(_impl_.transformation_meta_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_mesh_data()) {
    _this->_impl_.mesh_data_ = new ::generated::Mesh_Data(*from._impl_.mesh_data_);
  }
  if (from._internal_has_transformation_meta()) {
    _this->_impl_.transformation_meta_ = new ::generated::Transformation_Meta(*from._impl_.transformation_meta_);
  }
  // @@protoc_insertion_point(copy_constructor:generated.Mesh_Data_TF_Meta)
}

inline void Mesh_Data_TF_Meta::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mesh_data_){nullptr}
    , decltype(_impl_.transformation_meta_){nullptr}
  };
}

Mesh_Data_TF_Meta::~Mesh_Data_TF_Meta() {
  // @@protoc_insertion_point(destructor:generated.Mesh_Data_TF_Meta)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Mesh_Data_TF_Meta::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.mesh_data_;
  if (this != internal_default_instance()) delete _impl_.transformation_meta_;
}

void Mesh_Data_TF_Meta::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Mesh_Data_TF_Meta::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.Mesh_Data_TF_Meta)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.mesh_data_ != nullptr) {
    delete _impl_.mesh_data_;
  }
  _impl_.mesh_data_ = nullptr;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.transformation_meta_ != nullptr);
    _impl_.transformation_meta_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Mesh_Data_TF_Meta::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .generated.Mesh_Data mesh_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_mesh_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .generated.Transformation_Meta transformation_meta = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_transformation_meta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Mesh_Data_TF_Meta::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.Mesh_Data_TF_Meta)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .generated.Mesh_Data mesh_data = 1;
  if (this->_internal_has_mesh_data()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::mesh_data(this),
        _Internal::mesh_data(this).GetCachedSize(), target, stream);
  }

  // optional .generated.Transformation_Meta transformation_meta = 2;
  if (_internal_has_transformation_meta()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::transformation_meta(this),
        _Internal::transformation_meta(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.Mesh_Data_TF_Meta)
  return target;
}

size_t Mesh_Data_TF_Meta::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.Mesh_Data_TF_Meta)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .generated.Mesh_Data mesh_data = 1;
  if (this->_internal_has_mesh_data()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.mesh_data_);
  }

  // optional .generated.Transformation_Meta transformation_meta = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.transformation_meta_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Mesh_Data_TF_Meta::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Mesh_Data_TF_Meta*>(
      &from));
}

void Mesh_Data_TF_Meta::MergeFrom(const Mesh_Data_TF_Meta& from) {
  Mesh_Data_TF_Meta* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.Mesh_Data_TF_Meta)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_mesh_data()) {
    _this->_internal_mutable_mesh_data()->::generated::Mesh_Data::MergeFrom(
        from._internal_mesh_data());
  }
  if (from._internal_has_transformation_meta()) {
    _this->_internal_mutable_transformation_meta()->::generated::Transformation_Meta::MergeFrom(
        from._internal_transformation_meta());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Mesh_Data_TF_Meta::CopyFrom(const Mesh_Data_TF_Meta& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.Mesh_Data_TF_Meta)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Mesh_Data_TF_Meta::IsInitialized() const {
  return true;
}

void Mesh_Data_TF_Meta::InternalSwap(Mesh_Data_TF_Meta* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Mesh_Data_TF_Meta, _impl_.transformation_meta_)
      + sizeof(Mesh_Data_TF_Meta::_impl_.transformation_meta_)
      - PROTOBUF_FIELD_OFFSET(Mesh_Data_TF_Meta, _impl_.mesh_data_)>(
          reinterpret_cast<char*>(&_impl_.mesh_data_),
          reinterpret_cast<char*>(&other->_impl_.mesh_data_));
}

std::string Mesh_Data_TF_Meta::GetTypeName() const {
  return "generated.Mesh_Data_TF_Meta";
}


// ===================================================================

class Vertex_3D_Meta::_Internal {
 public:
  using HasBits = decltype(std::declval<Vertex_3D_Meta>()._impl_._has_bits_);
  static const ::generated::vertex_3d& vertex(const Vertex_3D_Meta* msg);
  static const ::generated::Transformation_Meta& transformation_meta(const Vertex_3D_Meta* msg);
  static void set_has_transformation_meta(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::generated::vertex_3d&
Vertex_3D_Meta::_Internal::vertex(const Vertex_3D_Meta* msg) {
  return *msg->_impl_.vertex_;
}
const ::generated::Transformation_Meta&
Vertex_3D_Meta::_Internal::transformation_meta(const Vertex_3D_Meta* msg) {
  return *msg->_impl_.transformation_meta_;
}
void Vertex_3D_Meta::clear_transformation_meta() {
  if (_impl_.transformation_meta_ != nullptr) _impl_.transformation_meta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
Vertex_3D_Meta::Vertex_3D_Meta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:generated.Vertex_3D_Meta)
}
Vertex_3D_Meta::Vertex_3D_Meta(const Vertex_3D_Meta& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Vertex_3D_Meta* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vertex_){nullptr}
    , decltype(_impl_.transformation_meta_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_vertex()) {
    _this->_impl_.vertex_ = new ::generated::vertex_3d(*from._impl_.vertex_);
  }
  if (from._internal_has_transformation_meta()) {
    _this->_impl_.transformation_meta_ = new ::generated::Transformation_Meta(*from._impl_.transformation_meta_);
  }
  // @@protoc_insertion_point(copy_constructor:generated.Vertex_3D_Meta)
}

inline void Vertex_3D_Meta::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vertex_){nullptr}
    , decltype(_impl_.transformation_meta_){nullptr}
  };
}

Vertex_3D_Meta::~Vertex_3D_Meta() {
  // @@protoc_insertion_point(destructor:generated.Vertex_3D_Meta)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Vertex_3D_Meta::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.vertex_;
  if (this != internal_default_instance()) delete _impl_.transformation_meta_;
}

void Vertex_3D_Meta::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Vertex_3D_Meta::Clear() {
// @@protoc_insertion_point(message_clear_start:generated.Vertex_3D_Meta)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.vertex_ != nullptr) {
    delete _impl_.vertex_;
  }
  _impl_.vertex_ = nullptr;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.transformation_meta_ != nullptr);
    _impl_.transformation_meta_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Vertex_3D_Meta::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .generated.vertex_3d vertex = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_vertex(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .generated.Transformation_Meta transformation_meta = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_transformation_meta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Vertex_3D_Meta::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:generated.Vertex_3D_Meta)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .generated.vertex_3d vertex = 1;
  if (this->_internal_has_vertex()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::vertex(this),
        _Internal::vertex(this).GetCachedSize(), target, stream);
  }

  // optional .generated.Transformation_Meta transformation_meta = 2;
  if (_internal_has_transformation_meta()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::transformation_meta(this),
        _Internal::transformation_meta(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:generated.Vertex_3D_Meta)
  return target;
}

size_t Vertex_3D_Meta::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:generated.Vertex_3D_Meta)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .generated.vertex_3d vertex = 1;
  if (this->_internal_has_vertex()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vertex_);
  }

  // optional .generated.Transformation_Meta transformation_meta = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.transformation_meta_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Vertex_3D_Meta::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Vertex_3D_Meta*>(
      &from));
}

void Vertex_3D_Meta::MergeFrom(const Vertex_3D_Meta& from) {
  Vertex_3D_Meta* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:generated.Vertex_3D_Meta)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_vertex()) {
    _this->_internal_mutable_vertex()->::generated::vertex_3d::MergeFrom(
        from._internal_vertex());
  }
  if (from._internal_has_transformation_meta()) {
    _this->_internal_mutable_transformation_meta()->::generated::Transformation_Meta::MergeFrom(
        from._internal_transformation_meta());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Vertex_3D_Meta::CopyFrom(const Vertex_3D_Meta& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:generated.Vertex_3D_Meta)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vertex_3D_Meta::IsInitialized() const {
  return true;
}

void Vertex_3D_Meta::InternalSwap(Vertex_3D_Meta* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vertex_3D_Meta, _impl_.transformation_meta_)
      + sizeof(Vertex_3D_Meta::_impl_.transformation_meta_)
      - PROTOBUF_FIELD_OFFSET(Vertex_3D_Meta, _impl_.vertex_)>(
          reinterpret_cast<char*>(&_impl_.vertex_),
          reinterpret_cast<char*>(&other->_impl_.vertex_));
}

std::string Vertex_3D_Meta::GetTypeName() const {
  return "generated.Vertex_3D_Meta";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace generated
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::generated::vertex_3d*
Arena::CreateMaybeMessage< ::generated::vertex_3d >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::vertex_3d >(arena);
}
template<> PROTOBUF_NOINLINE ::generated::Rotation_3d*
Arena::CreateMaybeMessage< ::generated::Rotation_3d >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::Rotation_3d >(arena);
}
template<> PROTOBUF_NOINLINE ::generated::index_3d*
Arena::CreateMaybeMessage< ::generated::index_3d >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::index_3d >(arena);
}
template<> PROTOBUF_NOINLINE ::generated::quaternion*
Arena::CreateMaybeMessage< ::generated::quaternion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::quaternion >(arena);
}
template<> PROTOBUF_NOINLINE ::generated::size_3d*
Arena::CreateMaybeMessage< ::generated::size_3d >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::size_3d >(arena);
}
template<> PROTOBUF_NOINLINE ::generated::vertex_4d*
Arena::CreateMaybeMessage< ::generated::vertex_4d >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::vertex_4d >(arena);
}
template<> PROTOBUF_NOINLINE ::generated::color*
Arena::CreateMaybeMessage< ::generated::color >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::color >(arena);
}
template<> PROTOBUF_NOINLINE ::generated::Matrix*
Arena::CreateMaybeMessage< ::generated::Matrix >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::Matrix >(arena);
}
template<> PROTOBUF_NOINLINE ::generated::vertex_3d_array*
Arena::CreateMaybeMessage< ::generated::vertex_3d_array >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::vertex_3d_array >(arena);
}
template<> PROTOBUF_NOINLINE ::generated::vertex_4d_array*
Arena::CreateMaybeMessage< ::generated::vertex_4d_array >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::vertex_4d_array >(arena);
}
template<> PROTOBUF_NOINLINE ::generated::color_array*
Arena::CreateMaybeMessage< ::generated::color_array >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::color_array >(arena);
}
template<> PROTOBUF_NOINLINE ::generated::Mesh_Data*
Arena::CreateMaybeMessage< ::generated::Mesh_Data >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::Mesh_Data >(arena);
}
template<> PROTOBUF_NOINLINE ::generated::aabb*
Arena::CreateMaybeMessage< ::generated::aabb >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::aabb >(arena);
}
template<> PROTOBUF_NOINLINE ::generated::obb*
Arena::CreateMaybeMessage< ::generated::obb >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::obb >(arena);
}
template<> PROTOBUF_NOINLINE ::generated::named_request*
Arena::CreateMaybeMessage< ::generated::named_request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::named_request >(arena);
}
template<> PROTOBUF_NOINLINE ::generated::Matrix_TF_Meta*
Arena::CreateMaybeMessage< ::generated::Matrix_TF_Meta >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::Matrix_TF_Meta >(arena);
}
template<> PROTOBUF_NOINLINE ::generated::Mesh_Data_TF_Meta*
Arena::CreateMaybeMessage< ::generated::Mesh_Data_TF_Meta >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::Mesh_Data_TF_Meta >(arena);
}
template<> PROTOBUF_NOINLINE ::generated::Vertex_3D_Meta*
Arena::CreateMaybeMessage< ::generated::Vertex_3D_Meta >(Arena* arena) {
  return Arena::CreateMessageInternal< ::generated::Vertex_3D_Meta >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
