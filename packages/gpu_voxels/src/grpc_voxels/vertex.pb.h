// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vertex.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_vertex_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_vertex_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "meta_data.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_vertex_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_vertex_2eproto {
  static const uint32_t offsets[];
};
namespace generated {
class Matrix;
struct MatrixDefaultTypeInternal;
extern MatrixDefaultTypeInternal _Matrix_default_instance_;
class Matrix_TF_Meta;
struct Matrix_TF_MetaDefaultTypeInternal;
extern Matrix_TF_MetaDefaultTypeInternal _Matrix_TF_Meta_default_instance_;
class Vertex_3D_Meta;
struct Vertex_3D_MetaDefaultTypeInternal;
extern Vertex_3D_MetaDefaultTypeInternal _Vertex_3D_Meta_default_instance_;
class aabb;
struct aabbDefaultTypeInternal;
extern aabbDefaultTypeInternal _aabb_default_instance_;
class color;
struct colorDefaultTypeInternal;
extern colorDefaultTypeInternal _color_default_instance_;
class color_array;
struct color_arrayDefaultTypeInternal;
extern color_arrayDefaultTypeInternal _color_array_default_instance_;
class mesh_data;
struct mesh_dataDefaultTypeInternal;
extern mesh_dataDefaultTypeInternal _mesh_data_default_instance_;
class named_request;
struct named_requestDefaultTypeInternal;
extern named_requestDefaultTypeInternal _named_request_default_instance_;
class obb;
struct obbDefaultTypeInternal;
extern obbDefaultTypeInternal _obb_default_instance_;
class quaternion;
struct quaternionDefaultTypeInternal;
extern quaternionDefaultTypeInternal _quaternion_default_instance_;
class size_3d;
struct size_3dDefaultTypeInternal;
extern size_3dDefaultTypeInternal _size_3d_default_instance_;
class vertex_3d;
struct vertex_3dDefaultTypeInternal;
extern vertex_3dDefaultTypeInternal _vertex_3d_default_instance_;
class vertex_3d_array;
struct vertex_3d_arrayDefaultTypeInternal;
extern vertex_3d_arrayDefaultTypeInternal _vertex_3d_array_default_instance_;
class vertex_3d_ui;
struct vertex_3d_uiDefaultTypeInternal;
extern vertex_3d_uiDefaultTypeInternal _vertex_3d_ui_default_instance_;
class vertex_4d;
struct vertex_4dDefaultTypeInternal;
extern vertex_4dDefaultTypeInternal _vertex_4d_default_instance_;
class vertex_4d_array;
struct vertex_4d_arrayDefaultTypeInternal;
extern vertex_4d_arrayDefaultTypeInternal _vertex_4d_array_default_instance_;
}  // namespace generated
PROTOBUF_NAMESPACE_OPEN
template<> ::generated::Matrix* Arena::CreateMaybeMessage<::generated::Matrix>(Arena*);
template<> ::generated::Matrix_TF_Meta* Arena::CreateMaybeMessage<::generated::Matrix_TF_Meta>(Arena*);
template<> ::generated::Vertex_3D_Meta* Arena::CreateMaybeMessage<::generated::Vertex_3D_Meta>(Arena*);
template<> ::generated::aabb* Arena::CreateMaybeMessage<::generated::aabb>(Arena*);
template<> ::generated::color* Arena::CreateMaybeMessage<::generated::color>(Arena*);
template<> ::generated::color_array* Arena::CreateMaybeMessage<::generated::color_array>(Arena*);
template<> ::generated::mesh_data* Arena::CreateMaybeMessage<::generated::mesh_data>(Arena*);
template<> ::generated::named_request* Arena::CreateMaybeMessage<::generated::named_request>(Arena*);
template<> ::generated::obb* Arena::CreateMaybeMessage<::generated::obb>(Arena*);
template<> ::generated::quaternion* Arena::CreateMaybeMessage<::generated::quaternion>(Arena*);
template<> ::generated::size_3d* Arena::CreateMaybeMessage<::generated::size_3d>(Arena*);
template<> ::generated::vertex_3d* Arena::CreateMaybeMessage<::generated::vertex_3d>(Arena*);
template<> ::generated::vertex_3d_array* Arena::CreateMaybeMessage<::generated::vertex_3d_array>(Arena*);
template<> ::generated::vertex_3d_ui* Arena::CreateMaybeMessage<::generated::vertex_3d_ui>(Arena*);
template<> ::generated::vertex_4d* Arena::CreateMaybeMessage<::generated::vertex_4d>(Arena*);
template<> ::generated::vertex_4d_array* Arena::CreateMaybeMessage<::generated::vertex_4d_array>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace generated {

// ===================================================================

class vertex_3d final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:generated.vertex_3d) */ {
 public:
  inline vertex_3d() : vertex_3d(nullptr) {}
  ~vertex_3d() override;
  explicit PROTOBUF_CONSTEXPR vertex_3d(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  vertex_3d(const vertex_3d& from);
  vertex_3d(vertex_3d&& from) noexcept
    : vertex_3d() {
    *this = ::std::move(from);
  }

  inline vertex_3d& operator=(const vertex_3d& from) {
    CopyFrom(from);
    return *this;
  }
  inline vertex_3d& operator=(vertex_3d&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const vertex_3d& default_instance() {
    return *internal_default_instance();
  }
  static inline const vertex_3d* internal_default_instance() {
    return reinterpret_cast<const vertex_3d*>(
               &_vertex_3d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(vertex_3d& a, vertex_3d& b) {
    a.Swap(&b);
  }
  inline void Swap(vertex_3d* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(vertex_3d* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  vertex_3d* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<vertex_3d>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const vertex_3d& from);
  void MergeFrom(const vertex_3d& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(vertex_3d* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.vertex_3d";
  }
  protected:
  explicit vertex_3d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:generated.vertex_3d)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vertex_2eproto;
};
// -------------------------------------------------------------------

class vertex_3d_ui final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:generated.vertex_3d_ui) */ {
 public:
  inline vertex_3d_ui() : vertex_3d_ui(nullptr) {}
  ~vertex_3d_ui() override;
  explicit PROTOBUF_CONSTEXPR vertex_3d_ui(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  vertex_3d_ui(const vertex_3d_ui& from);
  vertex_3d_ui(vertex_3d_ui&& from) noexcept
    : vertex_3d_ui() {
    *this = ::std::move(from);
  }

  inline vertex_3d_ui& operator=(const vertex_3d_ui& from) {
    CopyFrom(from);
    return *this;
  }
  inline vertex_3d_ui& operator=(vertex_3d_ui&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const vertex_3d_ui& default_instance() {
    return *internal_default_instance();
  }
  static inline const vertex_3d_ui* internal_default_instance() {
    return reinterpret_cast<const vertex_3d_ui*>(
               &_vertex_3d_ui_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(vertex_3d_ui& a, vertex_3d_ui& b) {
    a.Swap(&b);
  }
  inline void Swap(vertex_3d_ui* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(vertex_3d_ui* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  vertex_3d_ui* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<vertex_3d_ui>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const vertex_3d_ui& from);
  void MergeFrom(const vertex_3d_ui& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(vertex_3d_ui* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.vertex_3d_ui";
  }
  protected:
  explicit vertex_3d_ui(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // uint32 x = 1;
  void clear_x();
  uint32_t x() const;
  void set_x(uint32_t value);
  private:
  uint32_t _internal_x() const;
  void _internal_set_x(uint32_t value);
  public:

  // uint32 y = 2;
  void clear_y();
  uint32_t y() const;
  void set_y(uint32_t value);
  private:
  uint32_t _internal_y() const;
  void _internal_set_y(uint32_t value);
  public:

  // uint32 z = 3;
  void clear_z();
  uint32_t z() const;
  void set_z(uint32_t value);
  private:
  uint32_t _internal_z() const;
  void _internal_set_z(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:generated.vertex_3d_ui)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t x_;
    uint32_t y_;
    uint32_t z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vertex_2eproto;
};
// -------------------------------------------------------------------

class quaternion final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:generated.quaternion) */ {
 public:
  inline quaternion() : quaternion(nullptr) {}
  ~quaternion() override;
  explicit PROTOBUF_CONSTEXPR quaternion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  quaternion(const quaternion& from);
  quaternion(quaternion&& from) noexcept
    : quaternion() {
    *this = ::std::move(from);
  }

  inline quaternion& operator=(const quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline quaternion& operator=(quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const quaternion* internal_default_instance() {
    return reinterpret_cast<const quaternion*>(
               &_quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(quaternion& a, quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(quaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(quaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<quaternion>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const quaternion& from);
  void MergeFrom(const quaternion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(quaternion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.quaternion";
  }
  protected:
  explicit quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float w = 4;
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // @@protoc_insertion_point(class_scope:generated.quaternion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    float w_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vertex_2eproto;
};
// -------------------------------------------------------------------

class size_3d final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:generated.size_3d) */ {
 public:
  inline size_3d() : size_3d(nullptr) {}
  ~size_3d() override;
  explicit PROTOBUF_CONSTEXPR size_3d(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  size_3d(const size_3d& from);
  size_3d(size_3d&& from) noexcept
    : size_3d() {
    *this = ::std::move(from);
  }

  inline size_3d& operator=(const size_3d& from) {
    CopyFrom(from);
    return *this;
  }
  inline size_3d& operator=(size_3d&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const size_3d& default_instance() {
    return *internal_default_instance();
  }
  static inline const size_3d* internal_default_instance() {
    return reinterpret_cast<const size_3d*>(
               &_size_3d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(size_3d& a, size_3d& b) {
    a.Swap(&b);
  }
  inline void Swap(size_3d* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(size_3d* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  size_3d* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<size_3d>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const size_3d& from);
  void MergeFrom(const size_3d& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(size_3d* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.size_3d";
  }
  protected:
  explicit size_3d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:generated.size_3d)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vertex_2eproto;
};
// -------------------------------------------------------------------

class vertex_4d final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:generated.vertex_4d) */ {
 public:
  inline vertex_4d() : vertex_4d(nullptr) {}
  ~vertex_4d() override;
  explicit PROTOBUF_CONSTEXPR vertex_4d(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  vertex_4d(const vertex_4d& from);
  vertex_4d(vertex_4d&& from) noexcept
    : vertex_4d() {
    *this = ::std::move(from);
  }

  inline vertex_4d& operator=(const vertex_4d& from) {
    CopyFrom(from);
    return *this;
  }
  inline vertex_4d& operator=(vertex_4d&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const vertex_4d& default_instance() {
    return *internal_default_instance();
  }
  static inline const vertex_4d* internal_default_instance() {
    return reinterpret_cast<const vertex_4d*>(
               &_vertex_4d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(vertex_4d& a, vertex_4d& b) {
    a.Swap(&b);
  }
  inline void Swap(vertex_4d* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(vertex_4d* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  vertex_4d* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<vertex_4d>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const vertex_4d& from);
  void MergeFrom(const vertex_4d& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(vertex_4d* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.vertex_4d";
  }
  protected:
  explicit vertex_4d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kV3DFieldNumber = 1,
    kWFieldNumber = 2,
  };
  // .generated.vertex_3d v3D = 1;
  bool has_v3d() const;
  private:
  bool _internal_has_v3d() const;
  public:
  void clear_v3d();
  const ::generated::vertex_3d& v3d() const;
  PROTOBUF_NODISCARD ::generated::vertex_3d* release_v3d();
  ::generated::vertex_3d* mutable_v3d();
  void set_allocated_v3d(::generated::vertex_3d* v3d);
  private:
  const ::generated::vertex_3d& _internal_v3d() const;
  ::generated::vertex_3d* _internal_mutable_v3d();
  public:
  void unsafe_arena_set_allocated_v3d(
      ::generated::vertex_3d* v3d);
  ::generated::vertex_3d* unsafe_arena_release_v3d();

  // float w = 2;
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // @@protoc_insertion_point(class_scope:generated.vertex_4d)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::generated::vertex_3d* v3d_;
    float w_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vertex_2eproto;
};
// -------------------------------------------------------------------

class color final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:generated.color) */ {
 public:
  inline color() : color(nullptr) {}
  ~color() override;
  explicit PROTOBUF_CONSTEXPR color(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  color(const color& from);
  color(color&& from) noexcept
    : color() {
    *this = ::std::move(from);
  }

  inline color& operator=(const color& from) {
    CopyFrom(from);
    return *this;
  }
  inline color& operator=(color&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const color& default_instance() {
    return *internal_default_instance();
  }
  static inline const color* internal_default_instance() {
    return reinterpret_cast<const color*>(
               &_color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(color& a, color& b) {
    a.Swap(&b);
  }
  inline void Swap(color* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(color* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  color* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<color>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const color& from);
  void MergeFrom(const color& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(color* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.color";
  }
  protected:
  explicit color(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
    kAFieldNumber = 4,
  };
  // uint32 r = 1;
  void clear_r();
  uint32_t r() const;
  void set_r(uint32_t value);
  private:
  uint32_t _internal_r() const;
  void _internal_set_r(uint32_t value);
  public:

  // uint32 g = 2;
  void clear_g();
  uint32_t g() const;
  void set_g(uint32_t value);
  private:
  uint32_t _internal_g() const;
  void _internal_set_g(uint32_t value);
  public:

  // uint32 b = 3;
  void clear_b();
  uint32_t b() const;
  void set_b(uint32_t value);
  private:
  uint32_t _internal_b() const;
  void _internal_set_b(uint32_t value);
  public:

  // uint32 a = 4;
  void clear_a();
  uint32_t a() const;
  void set_a(uint32_t value);
  private:
  uint32_t _internal_a() const;
  void _internal_set_a(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:generated.color)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t r_;
    uint32_t g_;
    uint32_t b_;
    uint32_t a_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vertex_2eproto;
};
// -------------------------------------------------------------------

class Matrix final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:generated.Matrix) */ {
 public:
  inline Matrix() : Matrix(nullptr) {}
  ~Matrix() override;
  explicit PROTOBUF_CONSTEXPR Matrix(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Matrix(const Matrix& from);
  Matrix(Matrix&& from) noexcept
    : Matrix() {
    *this = ::std::move(from);
  }

  inline Matrix& operator=(const Matrix& from) {
    CopyFrom(from);
    return *this;
  }
  inline Matrix& operator=(Matrix&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Matrix& default_instance() {
    return *internal_default_instance();
  }
  static inline const Matrix* internal_default_instance() {
    return reinterpret_cast<const Matrix*>(
               &_Matrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Matrix& a, Matrix& b) {
    a.Swap(&b);
  }
  inline void Swap(Matrix* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Matrix* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Matrix* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Matrix>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Matrix& from);
  void MergeFrom(const Matrix& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Matrix* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.Matrix";
  }
  protected:
  explicit Matrix(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kRowsFieldNumber = 1,
    kColsFieldNumber = 2,
  };
  // repeated float data = 3 [packed = true];
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  float _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_data() const;
  void _internal_add_data(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_data();
  public:
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_data();

  // uint32 rows = 1;
  void clear_rows();
  uint32_t rows() const;
  void set_rows(uint32_t value);
  private:
  uint32_t _internal_rows() const;
  void _internal_set_rows(uint32_t value);
  public:

  // uint32 cols = 2;
  void clear_cols();
  uint32_t cols() const;
  void set_cols(uint32_t value);
  private:
  uint32_t _internal_cols() const;
  void _internal_set_cols(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:generated.Matrix)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > data_;
    uint32_t rows_;
    uint32_t cols_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vertex_2eproto;
};
// -------------------------------------------------------------------

class vertex_3d_array final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:generated.vertex_3d_array) */ {
 public:
  inline vertex_3d_array() : vertex_3d_array(nullptr) {}
  ~vertex_3d_array() override;
  explicit PROTOBUF_CONSTEXPR vertex_3d_array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  vertex_3d_array(const vertex_3d_array& from);
  vertex_3d_array(vertex_3d_array&& from) noexcept
    : vertex_3d_array() {
    *this = ::std::move(from);
  }

  inline vertex_3d_array& operator=(const vertex_3d_array& from) {
    CopyFrom(from);
    return *this;
  }
  inline vertex_3d_array& operator=(vertex_3d_array&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const vertex_3d_array& default_instance() {
    return *internal_default_instance();
  }
  static inline const vertex_3d_array* internal_default_instance() {
    return reinterpret_cast<const vertex_3d_array*>(
               &_vertex_3d_array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(vertex_3d_array& a, vertex_3d_array& b) {
    a.Swap(&b);
  }
  inline void Swap(vertex_3d_array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(vertex_3d_array* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  vertex_3d_array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<vertex_3d_array>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const vertex_3d_array& from);
  void MergeFrom(const vertex_3d_array& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(vertex_3d_array* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.vertex_3d_array";
  }
  protected:
  explicit vertex_3d_array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
  };
  // repeated .generated.vertex_3d vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  ::generated::vertex_3d* mutable_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::vertex_3d >*
      mutable_vertices();
  private:
  const ::generated::vertex_3d& _internal_vertices(int index) const;
  ::generated::vertex_3d* _internal_add_vertices();
  public:
  const ::generated::vertex_3d& vertices(int index) const;
  ::generated::vertex_3d* add_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::vertex_3d >&
      vertices() const;

  // @@protoc_insertion_point(class_scope:generated.vertex_3d_array)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::vertex_3d > vertices_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vertex_2eproto;
};
// -------------------------------------------------------------------

class vertex_4d_array final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:generated.vertex_4d_array) */ {
 public:
  inline vertex_4d_array() : vertex_4d_array(nullptr) {}
  ~vertex_4d_array() override;
  explicit PROTOBUF_CONSTEXPR vertex_4d_array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  vertex_4d_array(const vertex_4d_array& from);
  vertex_4d_array(vertex_4d_array&& from) noexcept
    : vertex_4d_array() {
    *this = ::std::move(from);
  }

  inline vertex_4d_array& operator=(const vertex_4d_array& from) {
    CopyFrom(from);
    return *this;
  }
  inline vertex_4d_array& operator=(vertex_4d_array&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const vertex_4d_array& default_instance() {
    return *internal_default_instance();
  }
  static inline const vertex_4d_array* internal_default_instance() {
    return reinterpret_cast<const vertex_4d_array*>(
               &_vertex_4d_array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(vertex_4d_array& a, vertex_4d_array& b) {
    a.Swap(&b);
  }
  inline void Swap(vertex_4d_array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(vertex_4d_array* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  vertex_4d_array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<vertex_4d_array>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const vertex_4d_array& from);
  void MergeFrom(const vertex_4d_array& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(vertex_4d_array* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.vertex_4d_array";
  }
  protected:
  explicit vertex_4d_array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
  };
  // repeated .generated.vertex_4d vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  ::generated::vertex_4d* mutable_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::vertex_4d >*
      mutable_vertices();
  private:
  const ::generated::vertex_4d& _internal_vertices(int index) const;
  ::generated::vertex_4d* _internal_add_vertices();
  public:
  const ::generated::vertex_4d& vertices(int index) const;
  ::generated::vertex_4d* add_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::vertex_4d >&
      vertices() const;

  // @@protoc_insertion_point(class_scope:generated.vertex_4d_array)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::vertex_4d > vertices_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vertex_2eproto;
};
// -------------------------------------------------------------------

class color_array final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:generated.color_array) */ {
 public:
  inline color_array() : color_array(nullptr) {}
  ~color_array() override;
  explicit PROTOBUF_CONSTEXPR color_array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  color_array(const color_array& from);
  color_array(color_array&& from) noexcept
    : color_array() {
    *this = ::std::move(from);
  }

  inline color_array& operator=(const color_array& from) {
    CopyFrom(from);
    return *this;
  }
  inline color_array& operator=(color_array&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const color_array& default_instance() {
    return *internal_default_instance();
  }
  static inline const color_array* internal_default_instance() {
    return reinterpret_cast<const color_array*>(
               &_color_array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(color_array& a, color_array& b) {
    a.Swap(&b);
  }
  inline void Swap(color_array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(color_array* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  color_array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<color_array>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const color_array& from);
  void MergeFrom(const color_array& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(color_array* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.color_array";
  }
  protected:
  explicit color_array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorsFieldNumber = 1,
  };
  // repeated .generated.color colors = 1;
  int colors_size() const;
  private:
  int _internal_colors_size() const;
  public:
  void clear_colors();
  ::generated::color* mutable_colors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::color >*
      mutable_colors();
  private:
  const ::generated::color& _internal_colors(int index) const;
  ::generated::color* _internal_add_colors();
  public:
  const ::generated::color& colors(int index) const;
  ::generated::color* add_colors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::color >&
      colors() const;

  // @@protoc_insertion_point(class_scope:generated.color_array)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::color > colors_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vertex_2eproto;
};
// -------------------------------------------------------------------

class mesh_data final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:generated.mesh_data) */ {
 public:
  inline mesh_data() : mesh_data(nullptr) {}
  ~mesh_data() override;
  explicit PROTOBUF_CONSTEXPR mesh_data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  mesh_data(const mesh_data& from);
  mesh_data(mesh_data&& from) noexcept
    : mesh_data() {
    *this = ::std::move(from);
  }

  inline mesh_data& operator=(const mesh_data& from) {
    CopyFrom(from);
    return *this;
  }
  inline mesh_data& operator=(mesh_data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const mesh_data& default_instance() {
    return *internal_default_instance();
  }
  static inline const mesh_data* internal_default_instance() {
    return reinterpret_cast<const mesh_data*>(
               &_mesh_data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(mesh_data& a, mesh_data& b) {
    a.Swap(&b);
  }
  inline void Swap(mesh_data* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mesh_data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  mesh_data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<mesh_data>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const mesh_data& from);
  void MergeFrom(const mesh_data& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(mesh_data* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.mesh_data";
  }
  protected:
  explicit mesh_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
    kIndicesFieldNumber = 2,
    kNameFieldNumber = 3,
    kVertexNormalsFieldNumber = 4,
    kVertexColorsFieldNumber = 5,
  };
  // repeated .generated.vertex_3d vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  ::generated::vertex_3d* mutable_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::vertex_3d >*
      mutable_vertices();
  private:
  const ::generated::vertex_3d& _internal_vertices(int index) const;
  ::generated::vertex_3d* _internal_add_vertices();
  public:
  const ::generated::vertex_3d& vertices(int index) const;
  ::generated::vertex_3d* add_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::vertex_3d >&
      vertices() const;

  // repeated uint32 indices = 2;
  int indices_size() const;
  private:
  int _internal_indices_size() const;
  public:
  void clear_indices();
  private:
  uint32_t _internal_indices(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_indices() const;
  void _internal_add_indices(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_indices();
  public:
  uint32_t indices(int index) const;
  void set_indices(int index, uint32_t value);
  void add_indices(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      indices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_indices();

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .generated.vertex_3d_array vertex_normals = 4;
  bool has_vertex_normals() const;
  private:
  bool _internal_has_vertex_normals() const;
  public:
  void clear_vertex_normals();
  const ::generated::vertex_3d_array& vertex_normals() const;
  PROTOBUF_NODISCARD ::generated::vertex_3d_array* release_vertex_normals();
  ::generated::vertex_3d_array* mutable_vertex_normals();
  void set_allocated_vertex_normals(::generated::vertex_3d_array* vertex_normals);
  private:
  const ::generated::vertex_3d_array& _internal_vertex_normals() const;
  ::generated::vertex_3d_array* _internal_mutable_vertex_normals();
  public:
  void unsafe_arena_set_allocated_vertex_normals(
      ::generated::vertex_3d_array* vertex_normals);
  ::generated::vertex_3d_array* unsafe_arena_release_vertex_normals();

  // optional .generated.color_array vertex_colors = 5;
  bool has_vertex_colors() const;
  private:
  bool _internal_has_vertex_colors() const;
  public:
  void clear_vertex_colors();
  const ::generated::color_array& vertex_colors() const;
  PROTOBUF_NODISCARD ::generated::color_array* release_vertex_colors();
  ::generated::color_array* mutable_vertex_colors();
  void set_allocated_vertex_colors(::generated::color_array* vertex_colors);
  private:
  const ::generated::color_array& _internal_vertex_colors() const;
  ::generated::color_array* _internal_mutable_vertex_colors();
  public:
  void unsafe_arena_set_allocated_vertex_colors(
      ::generated::color_array* vertex_colors);
  ::generated::color_array* unsafe_arena_release_vertex_colors();

  // @@protoc_insertion_point(class_scope:generated.mesh_data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::vertex_3d > vertices_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > indices_;
    mutable std::atomic<int> _indices_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::generated::vertex_3d_array* vertex_normals_;
    ::generated::color_array* vertex_colors_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vertex_2eproto;
};
// -------------------------------------------------------------------

class aabb final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:generated.aabb) */ {
 public:
  inline aabb() : aabb(nullptr) {}
  ~aabb() override;
  explicit PROTOBUF_CONSTEXPR aabb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  aabb(const aabb& from);
  aabb(aabb&& from) noexcept
    : aabb() {
    *this = ::std::move(from);
  }

  inline aabb& operator=(const aabb& from) {
    CopyFrom(from);
    return *this;
  }
  inline aabb& operator=(aabb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const aabb& default_instance() {
    return *internal_default_instance();
  }
  static inline const aabb* internal_default_instance() {
    return reinterpret_cast<const aabb*>(
               &_aabb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(aabb& a, aabb& b) {
    a.Swap(&b);
  }
  inline void Swap(aabb* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(aabb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  aabb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<aabb>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const aabb& from);
  void MergeFrom(const aabb& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(aabb* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.aabb";
  }
  protected:
  explicit aabb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiagonalFieldNumber = 1,
    kTranslationFieldNumber = 2,
  };
  // .generated.size_3d diagonal = 1;
  bool has_diagonal() const;
  private:
  bool _internal_has_diagonal() const;
  public:
  void clear_diagonal();
  const ::generated::size_3d& diagonal() const;
  PROTOBUF_NODISCARD ::generated::size_3d* release_diagonal();
  ::generated::size_3d* mutable_diagonal();
  void set_allocated_diagonal(::generated::size_3d* diagonal);
  private:
  const ::generated::size_3d& _internal_diagonal() const;
  ::generated::size_3d* _internal_mutable_diagonal();
  public:
  void unsafe_arena_set_allocated_diagonal(
      ::generated::size_3d* diagonal);
  ::generated::size_3d* unsafe_arena_release_diagonal();

  // .generated.vertex_3d translation = 2;
  bool has_translation() const;
  private:
  bool _internal_has_translation() const;
  public:
  void clear_translation();
  const ::generated::vertex_3d& translation() const;
  PROTOBUF_NODISCARD ::generated::vertex_3d* release_translation();
  ::generated::vertex_3d* mutable_translation();
  void set_allocated_translation(::generated::vertex_3d* translation);
  private:
  const ::generated::vertex_3d& _internal_translation() const;
  ::generated::vertex_3d* _internal_mutable_translation();
  public:
  void unsafe_arena_set_allocated_translation(
      ::generated::vertex_3d* translation);
  ::generated::vertex_3d* unsafe_arena_release_translation();

  // @@protoc_insertion_point(class_scope:generated.aabb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::generated::size_3d* diagonal_;
    ::generated::vertex_3d* translation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vertex_2eproto;
};
// -------------------------------------------------------------------

class obb final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:generated.obb) */ {
 public:
  inline obb() : obb(nullptr) {}
  ~obb() override;
  explicit PROTOBUF_CONSTEXPR obb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  obb(const obb& from);
  obb(obb&& from) noexcept
    : obb() {
    *this = ::std::move(from);
  }

  inline obb& operator=(const obb& from) {
    CopyFrom(from);
    return *this;
  }
  inline obb& operator=(obb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const obb& default_instance() {
    return *internal_default_instance();
  }
  static inline const obb* internal_default_instance() {
    return reinterpret_cast<const obb*>(
               &_obb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(obb& a, obb& b) {
    a.Swap(&b);
  }
  inline void Swap(obb* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(obb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  obb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<obb>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const obb& from);
  void MergeFrom(const obb& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(obb* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.obb";
  }
  protected:
  explicit obb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAxisAlignedFieldNumber = 1,
    kRotationFieldNumber = 2,
  };
  // .generated.aabb axis_aligned = 1;
  bool has_axis_aligned() const;
  private:
  bool _internal_has_axis_aligned() const;
  public:
  void clear_axis_aligned();
  const ::generated::aabb& axis_aligned() const;
  PROTOBUF_NODISCARD ::generated::aabb* release_axis_aligned();
  ::generated::aabb* mutable_axis_aligned();
  void set_allocated_axis_aligned(::generated::aabb* axis_aligned);
  private:
  const ::generated::aabb& _internal_axis_aligned() const;
  ::generated::aabb* _internal_mutable_axis_aligned();
  public:
  void unsafe_arena_set_allocated_axis_aligned(
      ::generated::aabb* axis_aligned);
  ::generated::aabb* unsafe_arena_release_axis_aligned();

  // .generated.quaternion rotation = 2;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::generated::quaternion& rotation() const;
  PROTOBUF_NODISCARD ::generated::quaternion* release_rotation();
  ::generated::quaternion* mutable_rotation();
  void set_allocated_rotation(::generated::quaternion* rotation);
  private:
  const ::generated::quaternion& _internal_rotation() const;
  ::generated::quaternion* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::generated::quaternion* rotation);
  ::generated::quaternion* unsafe_arena_release_rotation();

  // @@protoc_insertion_point(class_scope:generated.obb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::generated::aabb* axis_aligned_;
    ::generated::quaternion* rotation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vertex_2eproto;
};
// -------------------------------------------------------------------

class named_request final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:generated.named_request) */ {
 public:
  inline named_request() : named_request(nullptr) {}
  ~named_request() override;
  explicit PROTOBUF_CONSTEXPR named_request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  named_request(const named_request& from);
  named_request(named_request&& from) noexcept
    : named_request() {
    *this = ::std::move(from);
  }

  inline named_request& operator=(const named_request& from) {
    CopyFrom(from);
    return *this;
  }
  inline named_request& operator=(named_request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const named_request& default_instance() {
    return *internal_default_instance();
  }
  static inline const named_request* internal_default_instance() {
    return reinterpret_cast<const named_request*>(
               &_named_request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(named_request& a, named_request& b) {
    a.Swap(&b);
  }
  inline void Swap(named_request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(named_request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  named_request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<named_request>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const named_request& from);
  void MergeFrom(const named_request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(named_request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.named_request";
  }
  protected:
  explicit named_request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:generated.named_request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vertex_2eproto;
};
// -------------------------------------------------------------------

class Matrix_TF_Meta final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:generated.Matrix_TF_Meta) */ {
 public:
  inline Matrix_TF_Meta() : Matrix_TF_Meta(nullptr) {}
  ~Matrix_TF_Meta() override;
  explicit PROTOBUF_CONSTEXPR Matrix_TF_Meta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Matrix_TF_Meta(const Matrix_TF_Meta& from);
  Matrix_TF_Meta(Matrix_TF_Meta&& from) noexcept
    : Matrix_TF_Meta() {
    *this = ::std::move(from);
  }

  inline Matrix_TF_Meta& operator=(const Matrix_TF_Meta& from) {
    CopyFrom(from);
    return *this;
  }
  inline Matrix_TF_Meta& operator=(Matrix_TF_Meta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Matrix_TF_Meta& default_instance() {
    return *internal_default_instance();
  }
  static inline const Matrix_TF_Meta* internal_default_instance() {
    return reinterpret_cast<const Matrix_TF_Meta*>(
               &_Matrix_TF_Meta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Matrix_TF_Meta& a, Matrix_TF_Meta& b) {
    a.Swap(&b);
  }
  inline void Swap(Matrix_TF_Meta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Matrix_TF_Meta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Matrix_TF_Meta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Matrix_TF_Meta>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Matrix_TF_Meta& from);
  void MergeFrom(const Matrix_TF_Meta& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Matrix_TF_Meta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.Matrix_TF_Meta";
  }
  protected:
  explicit Matrix_TF_Meta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatrixFieldNumber = 1,
    kTransformationMetaFieldNumber = 2,
  };
  // .generated.Matrix matrix = 1;
  bool has_matrix() const;
  private:
  bool _internal_has_matrix() const;
  public:
  void clear_matrix();
  const ::generated::Matrix& matrix() const;
  PROTOBUF_NODISCARD ::generated::Matrix* release_matrix();
  ::generated::Matrix* mutable_matrix();
  void set_allocated_matrix(::generated::Matrix* matrix);
  private:
  const ::generated::Matrix& _internal_matrix() const;
  ::generated::Matrix* _internal_mutable_matrix();
  public:
  void unsafe_arena_set_allocated_matrix(
      ::generated::Matrix* matrix);
  ::generated::Matrix* unsafe_arena_release_matrix();

  // optional .generated.Transformation_Meta transformation_meta = 2;
  bool has_transformation_meta() const;
  private:
  bool _internal_has_transformation_meta() const;
  public:
  void clear_transformation_meta();
  const ::generated::Transformation_Meta& transformation_meta() const;
  PROTOBUF_NODISCARD ::generated::Transformation_Meta* release_transformation_meta();
  ::generated::Transformation_Meta* mutable_transformation_meta();
  void set_allocated_transformation_meta(::generated::Transformation_Meta* transformation_meta);
  private:
  const ::generated::Transformation_Meta& _internal_transformation_meta() const;
  ::generated::Transformation_Meta* _internal_mutable_transformation_meta();
  public:
  void unsafe_arena_set_allocated_transformation_meta(
      ::generated::Transformation_Meta* transformation_meta);
  ::generated::Transformation_Meta* unsafe_arena_release_transformation_meta();

  // @@protoc_insertion_point(class_scope:generated.Matrix_TF_Meta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::generated::Matrix* matrix_;
    ::generated::Transformation_Meta* transformation_meta_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vertex_2eproto;
};
// -------------------------------------------------------------------

class Vertex_3D_Meta final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:generated.Vertex_3D_Meta) */ {
 public:
  inline Vertex_3D_Meta() : Vertex_3D_Meta(nullptr) {}
  ~Vertex_3D_Meta() override;
  explicit PROTOBUF_CONSTEXPR Vertex_3D_Meta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vertex_3D_Meta(const Vertex_3D_Meta& from);
  Vertex_3D_Meta(Vertex_3D_Meta&& from) noexcept
    : Vertex_3D_Meta() {
    *this = ::std::move(from);
  }

  inline Vertex_3D_Meta& operator=(const Vertex_3D_Meta& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vertex_3D_Meta& operator=(Vertex_3D_Meta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Vertex_3D_Meta& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vertex_3D_Meta* internal_default_instance() {
    return reinterpret_cast<const Vertex_3D_Meta*>(
               &_Vertex_3D_Meta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Vertex_3D_Meta& a, Vertex_3D_Meta& b) {
    a.Swap(&b);
  }
  inline void Swap(Vertex_3D_Meta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vertex_3D_Meta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vertex_3D_Meta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vertex_3D_Meta>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Vertex_3D_Meta& from);
  void MergeFrom(const Vertex_3D_Meta& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vertex_3D_Meta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.Vertex_3D_Meta";
  }
  protected:
  explicit Vertex_3D_Meta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVertexFieldNumber = 1,
    kTransformationMetaFieldNumber = 2,
  };
  // .generated.vertex_3d vertex = 1;
  bool has_vertex() const;
  private:
  bool _internal_has_vertex() const;
  public:
  void clear_vertex();
  const ::generated::vertex_3d& vertex() const;
  PROTOBUF_NODISCARD ::generated::vertex_3d* release_vertex();
  ::generated::vertex_3d* mutable_vertex();
  void set_allocated_vertex(::generated::vertex_3d* vertex);
  private:
  const ::generated::vertex_3d& _internal_vertex() const;
  ::generated::vertex_3d* _internal_mutable_vertex();
  public:
  void unsafe_arena_set_allocated_vertex(
      ::generated::vertex_3d* vertex);
  ::generated::vertex_3d* unsafe_arena_release_vertex();

  // optional .generated.Transformation_Meta transformation_meta = 2;
  bool has_transformation_meta() const;
  private:
  bool _internal_has_transformation_meta() const;
  public:
  void clear_transformation_meta();
  const ::generated::Transformation_Meta& transformation_meta() const;
  PROTOBUF_NODISCARD ::generated::Transformation_Meta* release_transformation_meta();
  ::generated::Transformation_Meta* mutable_transformation_meta();
  void set_allocated_transformation_meta(::generated::Transformation_Meta* transformation_meta);
  private:
  const ::generated::Transformation_Meta& _internal_transformation_meta() const;
  ::generated::Transformation_Meta* _internal_mutable_transformation_meta();
  public:
  void unsafe_arena_set_allocated_transformation_meta(
      ::generated::Transformation_Meta* transformation_meta);
  ::generated::Transformation_Meta* unsafe_arena_release_transformation_meta();

  // @@protoc_insertion_point(class_scope:generated.Vertex_3D_Meta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::generated::vertex_3d* vertex_;
    ::generated::Transformation_Meta* transformation_meta_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vertex_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// vertex_3d

// float x = 1;
inline void vertex_3d::clear_x() {
  _impl_.x_ = 0;
}
inline float vertex_3d::_internal_x() const {
  return _impl_.x_;
}
inline float vertex_3d::x() const {
  // @@protoc_insertion_point(field_get:generated.vertex_3d.x)
  return _internal_x();
}
inline void vertex_3d::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void vertex_3d::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:generated.vertex_3d.x)
}

// float y = 2;
inline void vertex_3d::clear_y() {
  _impl_.y_ = 0;
}
inline float vertex_3d::_internal_y() const {
  return _impl_.y_;
}
inline float vertex_3d::y() const {
  // @@protoc_insertion_point(field_get:generated.vertex_3d.y)
  return _internal_y();
}
inline void vertex_3d::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void vertex_3d::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:generated.vertex_3d.y)
}

// float z = 3;
inline void vertex_3d::clear_z() {
  _impl_.z_ = 0;
}
inline float vertex_3d::_internal_z() const {
  return _impl_.z_;
}
inline float vertex_3d::z() const {
  // @@protoc_insertion_point(field_get:generated.vertex_3d.z)
  return _internal_z();
}
inline void vertex_3d::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void vertex_3d::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:generated.vertex_3d.z)
}

// -------------------------------------------------------------------

// vertex_3d_ui

// uint32 x = 1;
inline void vertex_3d_ui::clear_x() {
  _impl_.x_ = 0u;
}
inline uint32_t vertex_3d_ui::_internal_x() const {
  return _impl_.x_;
}
inline uint32_t vertex_3d_ui::x() const {
  // @@protoc_insertion_point(field_get:generated.vertex_3d_ui.x)
  return _internal_x();
}
inline void vertex_3d_ui::_internal_set_x(uint32_t value) {
  
  _impl_.x_ = value;
}
inline void vertex_3d_ui::set_x(uint32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:generated.vertex_3d_ui.x)
}

// uint32 y = 2;
inline void vertex_3d_ui::clear_y() {
  _impl_.y_ = 0u;
}
inline uint32_t vertex_3d_ui::_internal_y() const {
  return _impl_.y_;
}
inline uint32_t vertex_3d_ui::y() const {
  // @@protoc_insertion_point(field_get:generated.vertex_3d_ui.y)
  return _internal_y();
}
inline void vertex_3d_ui::_internal_set_y(uint32_t value) {
  
  _impl_.y_ = value;
}
inline void vertex_3d_ui::set_y(uint32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:generated.vertex_3d_ui.y)
}

// uint32 z = 3;
inline void vertex_3d_ui::clear_z() {
  _impl_.z_ = 0u;
}
inline uint32_t vertex_3d_ui::_internal_z() const {
  return _impl_.z_;
}
inline uint32_t vertex_3d_ui::z() const {
  // @@protoc_insertion_point(field_get:generated.vertex_3d_ui.z)
  return _internal_z();
}
inline void vertex_3d_ui::_internal_set_z(uint32_t value) {
  
  _impl_.z_ = value;
}
inline void vertex_3d_ui::set_z(uint32_t value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:generated.vertex_3d_ui.z)
}

// -------------------------------------------------------------------

// quaternion

// float x = 1;
inline void quaternion::clear_x() {
  _impl_.x_ = 0;
}
inline float quaternion::_internal_x() const {
  return _impl_.x_;
}
inline float quaternion::x() const {
  // @@protoc_insertion_point(field_get:generated.quaternion.x)
  return _internal_x();
}
inline void quaternion::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void quaternion::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:generated.quaternion.x)
}

// float y = 2;
inline void quaternion::clear_y() {
  _impl_.y_ = 0;
}
inline float quaternion::_internal_y() const {
  return _impl_.y_;
}
inline float quaternion::y() const {
  // @@protoc_insertion_point(field_get:generated.quaternion.y)
  return _internal_y();
}
inline void quaternion::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void quaternion::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:generated.quaternion.y)
}

// float z = 3;
inline void quaternion::clear_z() {
  _impl_.z_ = 0;
}
inline float quaternion::_internal_z() const {
  return _impl_.z_;
}
inline float quaternion::z() const {
  // @@protoc_insertion_point(field_get:generated.quaternion.z)
  return _internal_z();
}
inline void quaternion::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void quaternion::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:generated.quaternion.z)
}

// float w = 4;
inline void quaternion::clear_w() {
  _impl_.w_ = 0;
}
inline float quaternion::_internal_w() const {
  return _impl_.w_;
}
inline float quaternion::w() const {
  // @@protoc_insertion_point(field_get:generated.quaternion.w)
  return _internal_w();
}
inline void quaternion::_internal_set_w(float value) {
  
  _impl_.w_ = value;
}
inline void quaternion::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:generated.quaternion.w)
}

// -------------------------------------------------------------------

// size_3d

// float x = 1;
inline void size_3d::clear_x() {
  _impl_.x_ = 0;
}
inline float size_3d::_internal_x() const {
  return _impl_.x_;
}
inline float size_3d::x() const {
  // @@protoc_insertion_point(field_get:generated.size_3d.x)
  return _internal_x();
}
inline void size_3d::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void size_3d::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:generated.size_3d.x)
}

// float y = 2;
inline void size_3d::clear_y() {
  _impl_.y_ = 0;
}
inline float size_3d::_internal_y() const {
  return _impl_.y_;
}
inline float size_3d::y() const {
  // @@protoc_insertion_point(field_get:generated.size_3d.y)
  return _internal_y();
}
inline void size_3d::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void size_3d::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:generated.size_3d.y)
}

// float z = 3;
inline void size_3d::clear_z() {
  _impl_.z_ = 0;
}
inline float size_3d::_internal_z() const {
  return _impl_.z_;
}
inline float size_3d::z() const {
  // @@protoc_insertion_point(field_get:generated.size_3d.z)
  return _internal_z();
}
inline void size_3d::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void size_3d::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:generated.size_3d.z)
}

// -------------------------------------------------------------------

// vertex_4d

// .generated.vertex_3d v3D = 1;
inline bool vertex_4d::_internal_has_v3d() const {
  return this != internal_default_instance() && _impl_.v3d_ != nullptr;
}
inline bool vertex_4d::has_v3d() const {
  return _internal_has_v3d();
}
inline void vertex_4d::clear_v3d() {
  if (GetArenaForAllocation() == nullptr && _impl_.v3d_ != nullptr) {
    delete _impl_.v3d_;
  }
  _impl_.v3d_ = nullptr;
}
inline const ::generated::vertex_3d& vertex_4d::_internal_v3d() const {
  const ::generated::vertex_3d* p = _impl_.v3d_;
  return p != nullptr ? *p : reinterpret_cast<const ::generated::vertex_3d&>(
      ::generated::_vertex_3d_default_instance_);
}
inline const ::generated::vertex_3d& vertex_4d::v3d() const {
  // @@protoc_insertion_point(field_get:generated.vertex_4d.v3D)
  return _internal_v3d();
}
inline void vertex_4d::unsafe_arena_set_allocated_v3d(
    ::generated::vertex_3d* v3d) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.v3d_);
  }
  _impl_.v3d_ = v3d;
  if (v3d) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:generated.vertex_4d.v3D)
}
inline ::generated::vertex_3d* vertex_4d::release_v3d() {
  
  ::generated::vertex_3d* temp = _impl_.v3d_;
  _impl_.v3d_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::generated::vertex_3d* vertex_4d::unsafe_arena_release_v3d() {
  // @@protoc_insertion_point(field_release:generated.vertex_4d.v3D)
  
  ::generated::vertex_3d* temp = _impl_.v3d_;
  _impl_.v3d_ = nullptr;
  return temp;
}
inline ::generated::vertex_3d* vertex_4d::_internal_mutable_v3d() {
  
  if (_impl_.v3d_ == nullptr) {
    auto* p = CreateMaybeMessage<::generated::vertex_3d>(GetArenaForAllocation());
    _impl_.v3d_ = p;
  }
  return _impl_.v3d_;
}
inline ::generated::vertex_3d* vertex_4d::mutable_v3d() {
  ::generated::vertex_3d* _msg = _internal_mutable_v3d();
  // @@protoc_insertion_point(field_mutable:generated.vertex_4d.v3D)
  return _msg;
}
inline void vertex_4d::set_allocated_v3d(::generated::vertex_3d* v3d) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.v3d_;
  }
  if (v3d) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(v3d);
    if (message_arena != submessage_arena) {
      v3d = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, v3d, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.v3d_ = v3d;
  // @@protoc_insertion_point(field_set_allocated:generated.vertex_4d.v3D)
}

// float w = 2;
inline void vertex_4d::clear_w() {
  _impl_.w_ = 0;
}
inline float vertex_4d::_internal_w() const {
  return _impl_.w_;
}
inline float vertex_4d::w() const {
  // @@protoc_insertion_point(field_get:generated.vertex_4d.w)
  return _internal_w();
}
inline void vertex_4d::_internal_set_w(float value) {
  
  _impl_.w_ = value;
}
inline void vertex_4d::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:generated.vertex_4d.w)
}

// -------------------------------------------------------------------

// color

// uint32 r = 1;
inline void color::clear_r() {
  _impl_.r_ = 0u;
}
inline uint32_t color::_internal_r() const {
  return _impl_.r_;
}
inline uint32_t color::r() const {
  // @@protoc_insertion_point(field_get:generated.color.r)
  return _internal_r();
}
inline void color::_internal_set_r(uint32_t value) {
  
  _impl_.r_ = value;
}
inline void color::set_r(uint32_t value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:generated.color.r)
}

// uint32 g = 2;
inline void color::clear_g() {
  _impl_.g_ = 0u;
}
inline uint32_t color::_internal_g() const {
  return _impl_.g_;
}
inline uint32_t color::g() const {
  // @@protoc_insertion_point(field_get:generated.color.g)
  return _internal_g();
}
inline void color::_internal_set_g(uint32_t value) {
  
  _impl_.g_ = value;
}
inline void color::set_g(uint32_t value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:generated.color.g)
}

// uint32 b = 3;
inline void color::clear_b() {
  _impl_.b_ = 0u;
}
inline uint32_t color::_internal_b() const {
  return _impl_.b_;
}
inline uint32_t color::b() const {
  // @@protoc_insertion_point(field_get:generated.color.b)
  return _internal_b();
}
inline void color::_internal_set_b(uint32_t value) {
  
  _impl_.b_ = value;
}
inline void color::set_b(uint32_t value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:generated.color.b)
}

// uint32 a = 4;
inline void color::clear_a() {
  _impl_.a_ = 0u;
}
inline uint32_t color::_internal_a() const {
  return _impl_.a_;
}
inline uint32_t color::a() const {
  // @@protoc_insertion_point(field_get:generated.color.a)
  return _internal_a();
}
inline void color::_internal_set_a(uint32_t value) {
  
  _impl_.a_ = value;
}
inline void color::set_a(uint32_t value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:generated.color.a)
}

// -------------------------------------------------------------------

// Matrix

// uint32 rows = 1;
inline void Matrix::clear_rows() {
  _impl_.rows_ = 0u;
}
inline uint32_t Matrix::_internal_rows() const {
  return _impl_.rows_;
}
inline uint32_t Matrix::rows() const {
  // @@protoc_insertion_point(field_get:generated.Matrix.rows)
  return _internal_rows();
}
inline void Matrix::_internal_set_rows(uint32_t value) {
  
  _impl_.rows_ = value;
}
inline void Matrix::set_rows(uint32_t value) {
  _internal_set_rows(value);
  // @@protoc_insertion_point(field_set:generated.Matrix.rows)
}

// uint32 cols = 2;
inline void Matrix::clear_cols() {
  _impl_.cols_ = 0u;
}
inline uint32_t Matrix::_internal_cols() const {
  return _impl_.cols_;
}
inline uint32_t Matrix::cols() const {
  // @@protoc_insertion_point(field_get:generated.Matrix.cols)
  return _internal_cols();
}
inline void Matrix::_internal_set_cols(uint32_t value) {
  
  _impl_.cols_ = value;
}
inline void Matrix::set_cols(uint32_t value) {
  _internal_set_cols(value);
  // @@protoc_insertion_point(field_set:generated.Matrix.cols)
}

// repeated float data = 3 [packed = true];
inline int Matrix::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int Matrix::data_size() const {
  return _internal_data_size();
}
inline void Matrix::clear_data() {
  _impl_.data_.Clear();
}
inline float Matrix::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline float Matrix::data(int index) const {
  // @@protoc_insertion_point(field_get:generated.Matrix.data)
  return _internal_data(index);
}
inline void Matrix::set_data(int index, float value) {
  _impl_.data_.Set(index, value);
  // @@protoc_insertion_point(field_set:generated.Matrix.data)
}
inline void Matrix::_internal_add_data(float value) {
  _impl_.data_.Add(value);
}
inline void Matrix::add_data(float value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:generated.Matrix.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Matrix::_internal_data() const {
  return _impl_.data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Matrix::data() const {
  // @@protoc_insertion_point(field_list:generated.Matrix.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Matrix::_internal_mutable_data() {
  return &_impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Matrix::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:generated.Matrix.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// vertex_3d_array

// repeated .generated.vertex_3d vertices = 1;
inline int vertex_3d_array::_internal_vertices_size() const {
  return _impl_.vertices_.size();
}
inline int vertex_3d_array::vertices_size() const {
  return _internal_vertices_size();
}
inline void vertex_3d_array::clear_vertices() {
  _impl_.vertices_.Clear();
}
inline ::generated::vertex_3d* vertex_3d_array::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:generated.vertex_3d_array.vertices)
  return _impl_.vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::vertex_3d >*
vertex_3d_array::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:generated.vertex_3d_array.vertices)
  return &_impl_.vertices_;
}
inline const ::generated::vertex_3d& vertex_3d_array::_internal_vertices(int index) const {
  return _impl_.vertices_.Get(index);
}
inline const ::generated::vertex_3d& vertex_3d_array::vertices(int index) const {
  // @@protoc_insertion_point(field_get:generated.vertex_3d_array.vertices)
  return _internal_vertices(index);
}
inline ::generated::vertex_3d* vertex_3d_array::_internal_add_vertices() {
  return _impl_.vertices_.Add();
}
inline ::generated::vertex_3d* vertex_3d_array::add_vertices() {
  ::generated::vertex_3d* _add = _internal_add_vertices();
  // @@protoc_insertion_point(field_add:generated.vertex_3d_array.vertices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::vertex_3d >&
vertex_3d_array::vertices() const {
  // @@protoc_insertion_point(field_list:generated.vertex_3d_array.vertices)
  return _impl_.vertices_;
}

// -------------------------------------------------------------------

// vertex_4d_array

// repeated .generated.vertex_4d vertices = 1;
inline int vertex_4d_array::_internal_vertices_size() const {
  return _impl_.vertices_.size();
}
inline int vertex_4d_array::vertices_size() const {
  return _internal_vertices_size();
}
inline void vertex_4d_array::clear_vertices() {
  _impl_.vertices_.Clear();
}
inline ::generated::vertex_4d* vertex_4d_array::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:generated.vertex_4d_array.vertices)
  return _impl_.vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::vertex_4d >*
vertex_4d_array::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:generated.vertex_4d_array.vertices)
  return &_impl_.vertices_;
}
inline const ::generated::vertex_4d& vertex_4d_array::_internal_vertices(int index) const {
  return _impl_.vertices_.Get(index);
}
inline const ::generated::vertex_4d& vertex_4d_array::vertices(int index) const {
  // @@protoc_insertion_point(field_get:generated.vertex_4d_array.vertices)
  return _internal_vertices(index);
}
inline ::generated::vertex_4d* vertex_4d_array::_internal_add_vertices() {
  return _impl_.vertices_.Add();
}
inline ::generated::vertex_4d* vertex_4d_array::add_vertices() {
  ::generated::vertex_4d* _add = _internal_add_vertices();
  // @@protoc_insertion_point(field_add:generated.vertex_4d_array.vertices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::vertex_4d >&
vertex_4d_array::vertices() const {
  // @@protoc_insertion_point(field_list:generated.vertex_4d_array.vertices)
  return _impl_.vertices_;
}

// -------------------------------------------------------------------

// color_array

// repeated .generated.color colors = 1;
inline int color_array::_internal_colors_size() const {
  return _impl_.colors_.size();
}
inline int color_array::colors_size() const {
  return _internal_colors_size();
}
inline void color_array::clear_colors() {
  _impl_.colors_.Clear();
}
inline ::generated::color* color_array::mutable_colors(int index) {
  // @@protoc_insertion_point(field_mutable:generated.color_array.colors)
  return _impl_.colors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::color >*
color_array::mutable_colors() {
  // @@protoc_insertion_point(field_mutable_list:generated.color_array.colors)
  return &_impl_.colors_;
}
inline const ::generated::color& color_array::_internal_colors(int index) const {
  return _impl_.colors_.Get(index);
}
inline const ::generated::color& color_array::colors(int index) const {
  // @@protoc_insertion_point(field_get:generated.color_array.colors)
  return _internal_colors(index);
}
inline ::generated::color* color_array::_internal_add_colors() {
  return _impl_.colors_.Add();
}
inline ::generated::color* color_array::add_colors() {
  ::generated::color* _add = _internal_add_colors();
  // @@protoc_insertion_point(field_add:generated.color_array.colors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::color >&
color_array::colors() const {
  // @@protoc_insertion_point(field_list:generated.color_array.colors)
  return _impl_.colors_;
}

// -------------------------------------------------------------------

// mesh_data

// repeated .generated.vertex_3d vertices = 1;
inline int mesh_data::_internal_vertices_size() const {
  return _impl_.vertices_.size();
}
inline int mesh_data::vertices_size() const {
  return _internal_vertices_size();
}
inline void mesh_data::clear_vertices() {
  _impl_.vertices_.Clear();
}
inline ::generated::vertex_3d* mesh_data::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:generated.mesh_data.vertices)
  return _impl_.vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::vertex_3d >*
mesh_data::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:generated.mesh_data.vertices)
  return &_impl_.vertices_;
}
inline const ::generated::vertex_3d& mesh_data::_internal_vertices(int index) const {
  return _impl_.vertices_.Get(index);
}
inline const ::generated::vertex_3d& mesh_data::vertices(int index) const {
  // @@protoc_insertion_point(field_get:generated.mesh_data.vertices)
  return _internal_vertices(index);
}
inline ::generated::vertex_3d* mesh_data::_internal_add_vertices() {
  return _impl_.vertices_.Add();
}
inline ::generated::vertex_3d* mesh_data::add_vertices() {
  ::generated::vertex_3d* _add = _internal_add_vertices();
  // @@protoc_insertion_point(field_add:generated.mesh_data.vertices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::generated::vertex_3d >&
mesh_data::vertices() const {
  // @@protoc_insertion_point(field_list:generated.mesh_data.vertices)
  return _impl_.vertices_;
}

// repeated uint32 indices = 2;
inline int mesh_data::_internal_indices_size() const {
  return _impl_.indices_.size();
}
inline int mesh_data::indices_size() const {
  return _internal_indices_size();
}
inline void mesh_data::clear_indices() {
  _impl_.indices_.Clear();
}
inline uint32_t mesh_data::_internal_indices(int index) const {
  return _impl_.indices_.Get(index);
}
inline uint32_t mesh_data::indices(int index) const {
  // @@protoc_insertion_point(field_get:generated.mesh_data.indices)
  return _internal_indices(index);
}
inline void mesh_data::set_indices(int index, uint32_t value) {
  _impl_.indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:generated.mesh_data.indices)
}
inline void mesh_data::_internal_add_indices(uint32_t value) {
  _impl_.indices_.Add(value);
}
inline void mesh_data::add_indices(uint32_t value) {
  _internal_add_indices(value);
  // @@protoc_insertion_point(field_add:generated.mesh_data.indices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
mesh_data::_internal_indices() const {
  return _impl_.indices_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
mesh_data::indices() const {
  // @@protoc_insertion_point(field_list:generated.mesh_data.indices)
  return _internal_indices();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
mesh_data::_internal_mutable_indices() {
  return &_impl_.indices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
mesh_data::mutable_indices() {
  // @@protoc_insertion_point(field_mutable_list:generated.mesh_data.indices)
  return _internal_mutable_indices();
}

// string name = 3;
inline void mesh_data::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& mesh_data::name() const {
  // @@protoc_insertion_point(field_get:generated.mesh_data.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void mesh_data::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:generated.mesh_data.name)
}
inline std::string* mesh_data::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:generated.mesh_data.name)
  return _s;
}
inline const std::string& mesh_data::_internal_name() const {
  return _impl_.name_.Get();
}
inline void mesh_data::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* mesh_data::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* mesh_data::release_name() {
  // @@protoc_insertion_point(field_release:generated.mesh_data.name)
  return _impl_.name_.Release();
}
inline void mesh_data::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:generated.mesh_data.name)
}

// optional .generated.vertex_3d_array vertex_normals = 4;
inline bool mesh_data::_internal_has_vertex_normals() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vertex_normals_ != nullptr);
  return value;
}
inline bool mesh_data::has_vertex_normals() const {
  return _internal_has_vertex_normals();
}
inline void mesh_data::clear_vertex_normals() {
  if (_impl_.vertex_normals_ != nullptr) _impl_.vertex_normals_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::generated::vertex_3d_array& mesh_data::_internal_vertex_normals() const {
  const ::generated::vertex_3d_array* p = _impl_.vertex_normals_;
  return p != nullptr ? *p : reinterpret_cast<const ::generated::vertex_3d_array&>(
      ::generated::_vertex_3d_array_default_instance_);
}
inline const ::generated::vertex_3d_array& mesh_data::vertex_normals() const {
  // @@protoc_insertion_point(field_get:generated.mesh_data.vertex_normals)
  return _internal_vertex_normals();
}
inline void mesh_data::unsafe_arena_set_allocated_vertex_normals(
    ::generated::vertex_3d_array* vertex_normals) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vertex_normals_);
  }
  _impl_.vertex_normals_ = vertex_normals;
  if (vertex_normals) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:generated.mesh_data.vertex_normals)
}
inline ::generated::vertex_3d_array* mesh_data::release_vertex_normals() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::generated::vertex_3d_array* temp = _impl_.vertex_normals_;
  _impl_.vertex_normals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::generated::vertex_3d_array* mesh_data::unsafe_arena_release_vertex_normals() {
  // @@protoc_insertion_point(field_release:generated.mesh_data.vertex_normals)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::generated::vertex_3d_array* temp = _impl_.vertex_normals_;
  _impl_.vertex_normals_ = nullptr;
  return temp;
}
inline ::generated::vertex_3d_array* mesh_data::_internal_mutable_vertex_normals() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.vertex_normals_ == nullptr) {
    auto* p = CreateMaybeMessage<::generated::vertex_3d_array>(GetArenaForAllocation());
    _impl_.vertex_normals_ = p;
  }
  return _impl_.vertex_normals_;
}
inline ::generated::vertex_3d_array* mesh_data::mutable_vertex_normals() {
  ::generated::vertex_3d_array* _msg = _internal_mutable_vertex_normals();
  // @@protoc_insertion_point(field_mutable:generated.mesh_data.vertex_normals)
  return _msg;
}
inline void mesh_data::set_allocated_vertex_normals(::generated::vertex_3d_array* vertex_normals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vertex_normals_;
  }
  if (vertex_normals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vertex_normals);
    if (message_arena != submessage_arena) {
      vertex_normals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vertex_normals, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vertex_normals_ = vertex_normals;
  // @@protoc_insertion_point(field_set_allocated:generated.mesh_data.vertex_normals)
}

// optional .generated.color_array vertex_colors = 5;
inline bool mesh_data::_internal_has_vertex_colors() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vertex_colors_ != nullptr);
  return value;
}
inline bool mesh_data::has_vertex_colors() const {
  return _internal_has_vertex_colors();
}
inline void mesh_data::clear_vertex_colors() {
  if (_impl_.vertex_colors_ != nullptr) _impl_.vertex_colors_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::generated::color_array& mesh_data::_internal_vertex_colors() const {
  const ::generated::color_array* p = _impl_.vertex_colors_;
  return p != nullptr ? *p : reinterpret_cast<const ::generated::color_array&>(
      ::generated::_color_array_default_instance_);
}
inline const ::generated::color_array& mesh_data::vertex_colors() const {
  // @@protoc_insertion_point(field_get:generated.mesh_data.vertex_colors)
  return _internal_vertex_colors();
}
inline void mesh_data::unsafe_arena_set_allocated_vertex_colors(
    ::generated::color_array* vertex_colors) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vertex_colors_);
  }
  _impl_.vertex_colors_ = vertex_colors;
  if (vertex_colors) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:generated.mesh_data.vertex_colors)
}
inline ::generated::color_array* mesh_data::release_vertex_colors() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::generated::color_array* temp = _impl_.vertex_colors_;
  _impl_.vertex_colors_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::generated::color_array* mesh_data::unsafe_arena_release_vertex_colors() {
  // @@protoc_insertion_point(field_release:generated.mesh_data.vertex_colors)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::generated::color_array* temp = _impl_.vertex_colors_;
  _impl_.vertex_colors_ = nullptr;
  return temp;
}
inline ::generated::color_array* mesh_data::_internal_mutable_vertex_colors() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.vertex_colors_ == nullptr) {
    auto* p = CreateMaybeMessage<::generated::color_array>(GetArenaForAllocation());
    _impl_.vertex_colors_ = p;
  }
  return _impl_.vertex_colors_;
}
inline ::generated::color_array* mesh_data::mutable_vertex_colors() {
  ::generated::color_array* _msg = _internal_mutable_vertex_colors();
  // @@protoc_insertion_point(field_mutable:generated.mesh_data.vertex_colors)
  return _msg;
}
inline void mesh_data::set_allocated_vertex_colors(::generated::color_array* vertex_colors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vertex_colors_;
  }
  if (vertex_colors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vertex_colors);
    if (message_arena != submessage_arena) {
      vertex_colors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vertex_colors, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.vertex_colors_ = vertex_colors;
  // @@protoc_insertion_point(field_set_allocated:generated.mesh_data.vertex_colors)
}

// -------------------------------------------------------------------

// aabb

// .generated.size_3d diagonal = 1;
inline bool aabb::_internal_has_diagonal() const {
  return this != internal_default_instance() && _impl_.diagonal_ != nullptr;
}
inline bool aabb::has_diagonal() const {
  return _internal_has_diagonal();
}
inline void aabb::clear_diagonal() {
  if (GetArenaForAllocation() == nullptr && _impl_.diagonal_ != nullptr) {
    delete _impl_.diagonal_;
  }
  _impl_.diagonal_ = nullptr;
}
inline const ::generated::size_3d& aabb::_internal_diagonal() const {
  const ::generated::size_3d* p = _impl_.diagonal_;
  return p != nullptr ? *p : reinterpret_cast<const ::generated::size_3d&>(
      ::generated::_size_3d_default_instance_);
}
inline const ::generated::size_3d& aabb::diagonal() const {
  // @@protoc_insertion_point(field_get:generated.aabb.diagonal)
  return _internal_diagonal();
}
inline void aabb::unsafe_arena_set_allocated_diagonal(
    ::generated::size_3d* diagonal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.diagonal_);
  }
  _impl_.diagonal_ = diagonal;
  if (diagonal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:generated.aabb.diagonal)
}
inline ::generated::size_3d* aabb::release_diagonal() {
  
  ::generated::size_3d* temp = _impl_.diagonal_;
  _impl_.diagonal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::generated::size_3d* aabb::unsafe_arena_release_diagonal() {
  // @@protoc_insertion_point(field_release:generated.aabb.diagonal)
  
  ::generated::size_3d* temp = _impl_.diagonal_;
  _impl_.diagonal_ = nullptr;
  return temp;
}
inline ::generated::size_3d* aabb::_internal_mutable_diagonal() {
  
  if (_impl_.diagonal_ == nullptr) {
    auto* p = CreateMaybeMessage<::generated::size_3d>(GetArenaForAllocation());
    _impl_.diagonal_ = p;
  }
  return _impl_.diagonal_;
}
inline ::generated::size_3d* aabb::mutable_diagonal() {
  ::generated::size_3d* _msg = _internal_mutable_diagonal();
  // @@protoc_insertion_point(field_mutable:generated.aabb.diagonal)
  return _msg;
}
inline void aabb::set_allocated_diagonal(::generated::size_3d* diagonal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.diagonal_;
  }
  if (diagonal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(diagonal);
    if (message_arena != submessage_arena) {
      diagonal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, diagonal, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.diagonal_ = diagonal;
  // @@protoc_insertion_point(field_set_allocated:generated.aabb.diagonal)
}

// .generated.vertex_3d translation = 2;
inline bool aabb::_internal_has_translation() const {
  return this != internal_default_instance() && _impl_.translation_ != nullptr;
}
inline bool aabb::has_translation() const {
  return _internal_has_translation();
}
inline void aabb::clear_translation() {
  if (GetArenaForAllocation() == nullptr && _impl_.translation_ != nullptr) {
    delete _impl_.translation_;
  }
  _impl_.translation_ = nullptr;
}
inline const ::generated::vertex_3d& aabb::_internal_translation() const {
  const ::generated::vertex_3d* p = _impl_.translation_;
  return p != nullptr ? *p : reinterpret_cast<const ::generated::vertex_3d&>(
      ::generated::_vertex_3d_default_instance_);
}
inline const ::generated::vertex_3d& aabb::translation() const {
  // @@protoc_insertion_point(field_get:generated.aabb.translation)
  return _internal_translation();
}
inline void aabb::unsafe_arena_set_allocated_translation(
    ::generated::vertex_3d* translation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.translation_);
  }
  _impl_.translation_ = translation;
  if (translation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:generated.aabb.translation)
}
inline ::generated::vertex_3d* aabb::release_translation() {
  
  ::generated::vertex_3d* temp = _impl_.translation_;
  _impl_.translation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::generated::vertex_3d* aabb::unsafe_arena_release_translation() {
  // @@protoc_insertion_point(field_release:generated.aabb.translation)
  
  ::generated::vertex_3d* temp = _impl_.translation_;
  _impl_.translation_ = nullptr;
  return temp;
}
inline ::generated::vertex_3d* aabb::_internal_mutable_translation() {
  
  if (_impl_.translation_ == nullptr) {
    auto* p = CreateMaybeMessage<::generated::vertex_3d>(GetArenaForAllocation());
    _impl_.translation_ = p;
  }
  return _impl_.translation_;
}
inline ::generated::vertex_3d* aabb::mutable_translation() {
  ::generated::vertex_3d* _msg = _internal_mutable_translation();
  // @@protoc_insertion_point(field_mutable:generated.aabb.translation)
  return _msg;
}
inline void aabb::set_allocated_translation(::generated::vertex_3d* translation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.translation_;
  }
  if (translation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(translation);
    if (message_arena != submessage_arena) {
      translation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, translation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.translation_ = translation;
  // @@protoc_insertion_point(field_set_allocated:generated.aabb.translation)
}

// -------------------------------------------------------------------

// obb

// .generated.aabb axis_aligned = 1;
inline bool obb::_internal_has_axis_aligned() const {
  return this != internal_default_instance() && _impl_.axis_aligned_ != nullptr;
}
inline bool obb::has_axis_aligned() const {
  return _internal_has_axis_aligned();
}
inline void obb::clear_axis_aligned() {
  if (GetArenaForAllocation() == nullptr && _impl_.axis_aligned_ != nullptr) {
    delete _impl_.axis_aligned_;
  }
  _impl_.axis_aligned_ = nullptr;
}
inline const ::generated::aabb& obb::_internal_axis_aligned() const {
  const ::generated::aabb* p = _impl_.axis_aligned_;
  return p != nullptr ? *p : reinterpret_cast<const ::generated::aabb&>(
      ::generated::_aabb_default_instance_);
}
inline const ::generated::aabb& obb::axis_aligned() const {
  // @@protoc_insertion_point(field_get:generated.obb.axis_aligned)
  return _internal_axis_aligned();
}
inline void obb::unsafe_arena_set_allocated_axis_aligned(
    ::generated::aabb* axis_aligned) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.axis_aligned_);
  }
  _impl_.axis_aligned_ = axis_aligned;
  if (axis_aligned) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:generated.obb.axis_aligned)
}
inline ::generated::aabb* obb::release_axis_aligned() {
  
  ::generated::aabb* temp = _impl_.axis_aligned_;
  _impl_.axis_aligned_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::generated::aabb* obb::unsafe_arena_release_axis_aligned() {
  // @@protoc_insertion_point(field_release:generated.obb.axis_aligned)
  
  ::generated::aabb* temp = _impl_.axis_aligned_;
  _impl_.axis_aligned_ = nullptr;
  return temp;
}
inline ::generated::aabb* obb::_internal_mutable_axis_aligned() {
  
  if (_impl_.axis_aligned_ == nullptr) {
    auto* p = CreateMaybeMessage<::generated::aabb>(GetArenaForAllocation());
    _impl_.axis_aligned_ = p;
  }
  return _impl_.axis_aligned_;
}
inline ::generated::aabb* obb::mutable_axis_aligned() {
  ::generated::aabb* _msg = _internal_mutable_axis_aligned();
  // @@protoc_insertion_point(field_mutable:generated.obb.axis_aligned)
  return _msg;
}
inline void obb::set_allocated_axis_aligned(::generated::aabb* axis_aligned) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.axis_aligned_;
  }
  if (axis_aligned) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(axis_aligned);
    if (message_arena != submessage_arena) {
      axis_aligned = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, axis_aligned, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.axis_aligned_ = axis_aligned;
  // @@protoc_insertion_point(field_set_allocated:generated.obb.axis_aligned)
}

// .generated.quaternion rotation = 2;
inline bool obb::_internal_has_rotation() const {
  return this != internal_default_instance() && _impl_.rotation_ != nullptr;
}
inline bool obb::has_rotation() const {
  return _internal_has_rotation();
}
inline void obb::clear_rotation() {
  if (GetArenaForAllocation() == nullptr && _impl_.rotation_ != nullptr) {
    delete _impl_.rotation_;
  }
  _impl_.rotation_ = nullptr;
}
inline const ::generated::quaternion& obb::_internal_rotation() const {
  const ::generated::quaternion* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::generated::quaternion&>(
      ::generated::_quaternion_default_instance_);
}
inline const ::generated::quaternion& obb::rotation() const {
  // @@protoc_insertion_point(field_get:generated.obb.rotation)
  return _internal_rotation();
}
inline void obb::unsafe_arena_set_allocated_rotation(
    ::generated::quaternion* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:generated.obb.rotation)
}
inline ::generated::quaternion* obb::release_rotation() {
  
  ::generated::quaternion* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::generated::quaternion* obb::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:generated.obb.rotation)
  
  ::generated::quaternion* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::generated::quaternion* obb::_internal_mutable_rotation() {
  
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::generated::quaternion>(GetArenaForAllocation());
    _impl_.rotation_ = p;
  }
  return _impl_.rotation_;
}
inline ::generated::quaternion* obb::mutable_rotation() {
  ::generated::quaternion* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:generated.obb.rotation)
  return _msg;
}
inline void obb::set_allocated_rotation(::generated::quaternion* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:generated.obb.rotation)
}

// -------------------------------------------------------------------

// named_request

// string name = 1;
inline void named_request::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& named_request::name() const {
  // @@protoc_insertion_point(field_get:generated.named_request.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void named_request::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:generated.named_request.name)
}
inline std::string* named_request::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:generated.named_request.name)
  return _s;
}
inline const std::string& named_request::_internal_name() const {
  return _impl_.name_.Get();
}
inline void named_request::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* named_request::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* named_request::release_name() {
  // @@protoc_insertion_point(field_release:generated.named_request.name)
  return _impl_.name_.Release();
}
inline void named_request::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:generated.named_request.name)
}

// -------------------------------------------------------------------

// Matrix_TF_Meta

// .generated.Matrix matrix = 1;
inline bool Matrix_TF_Meta::_internal_has_matrix() const {
  return this != internal_default_instance() && _impl_.matrix_ != nullptr;
}
inline bool Matrix_TF_Meta::has_matrix() const {
  return _internal_has_matrix();
}
inline void Matrix_TF_Meta::clear_matrix() {
  if (GetArenaForAllocation() == nullptr && _impl_.matrix_ != nullptr) {
    delete _impl_.matrix_;
  }
  _impl_.matrix_ = nullptr;
}
inline const ::generated::Matrix& Matrix_TF_Meta::_internal_matrix() const {
  const ::generated::Matrix* p = _impl_.matrix_;
  return p != nullptr ? *p : reinterpret_cast<const ::generated::Matrix&>(
      ::generated::_Matrix_default_instance_);
}
inline const ::generated::Matrix& Matrix_TF_Meta::matrix() const {
  // @@protoc_insertion_point(field_get:generated.Matrix_TF_Meta.matrix)
  return _internal_matrix();
}
inline void Matrix_TF_Meta::unsafe_arena_set_allocated_matrix(
    ::generated::Matrix* matrix) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.matrix_);
  }
  _impl_.matrix_ = matrix;
  if (matrix) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:generated.Matrix_TF_Meta.matrix)
}
inline ::generated::Matrix* Matrix_TF_Meta::release_matrix() {
  
  ::generated::Matrix* temp = _impl_.matrix_;
  _impl_.matrix_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::generated::Matrix* Matrix_TF_Meta::unsafe_arena_release_matrix() {
  // @@protoc_insertion_point(field_release:generated.Matrix_TF_Meta.matrix)
  
  ::generated::Matrix* temp = _impl_.matrix_;
  _impl_.matrix_ = nullptr;
  return temp;
}
inline ::generated::Matrix* Matrix_TF_Meta::_internal_mutable_matrix() {
  
  if (_impl_.matrix_ == nullptr) {
    auto* p = CreateMaybeMessage<::generated::Matrix>(GetArenaForAllocation());
    _impl_.matrix_ = p;
  }
  return _impl_.matrix_;
}
inline ::generated::Matrix* Matrix_TF_Meta::mutable_matrix() {
  ::generated::Matrix* _msg = _internal_mutable_matrix();
  // @@protoc_insertion_point(field_mutable:generated.Matrix_TF_Meta.matrix)
  return _msg;
}
inline void Matrix_TF_Meta::set_allocated_matrix(::generated::Matrix* matrix) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.matrix_;
  }
  if (matrix) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(matrix);
    if (message_arena != submessage_arena) {
      matrix = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, matrix, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.matrix_ = matrix;
  // @@protoc_insertion_point(field_set_allocated:generated.Matrix_TF_Meta.matrix)
}

// optional .generated.Transformation_Meta transformation_meta = 2;
inline bool Matrix_TF_Meta::_internal_has_transformation_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transformation_meta_ != nullptr);
  return value;
}
inline bool Matrix_TF_Meta::has_transformation_meta() const {
  return _internal_has_transformation_meta();
}
inline const ::generated::Transformation_Meta& Matrix_TF_Meta::_internal_transformation_meta() const {
  const ::generated::Transformation_Meta* p = _impl_.transformation_meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::generated::Transformation_Meta&>(
      ::generated::_Transformation_Meta_default_instance_);
}
inline const ::generated::Transformation_Meta& Matrix_TF_Meta::transformation_meta() const {
  // @@protoc_insertion_point(field_get:generated.Matrix_TF_Meta.transformation_meta)
  return _internal_transformation_meta();
}
inline void Matrix_TF_Meta::unsafe_arena_set_allocated_transformation_meta(
    ::generated::Transformation_Meta* transformation_meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transformation_meta_);
  }
  _impl_.transformation_meta_ = transformation_meta;
  if (transformation_meta) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:generated.Matrix_TF_Meta.transformation_meta)
}
inline ::generated::Transformation_Meta* Matrix_TF_Meta::release_transformation_meta() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::generated::Transformation_Meta* temp = _impl_.transformation_meta_;
  _impl_.transformation_meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::generated::Transformation_Meta* Matrix_TF_Meta::unsafe_arena_release_transformation_meta() {
  // @@protoc_insertion_point(field_release:generated.Matrix_TF_Meta.transformation_meta)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::generated::Transformation_Meta* temp = _impl_.transformation_meta_;
  _impl_.transformation_meta_ = nullptr;
  return temp;
}
inline ::generated::Transformation_Meta* Matrix_TF_Meta::_internal_mutable_transformation_meta() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transformation_meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::generated::Transformation_Meta>(GetArenaForAllocation());
    _impl_.transformation_meta_ = p;
  }
  return _impl_.transformation_meta_;
}
inline ::generated::Transformation_Meta* Matrix_TF_Meta::mutable_transformation_meta() {
  ::generated::Transformation_Meta* _msg = _internal_mutable_transformation_meta();
  // @@protoc_insertion_point(field_mutable:generated.Matrix_TF_Meta.transformation_meta)
  return _msg;
}
inline void Matrix_TF_Meta::set_allocated_transformation_meta(::generated::Transformation_Meta* transformation_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transformation_meta_);
  }
  if (transformation_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transformation_meta));
    if (message_arena != submessage_arena) {
      transformation_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transformation_meta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.transformation_meta_ = transformation_meta;
  // @@protoc_insertion_point(field_set_allocated:generated.Matrix_TF_Meta.transformation_meta)
}

// -------------------------------------------------------------------

// Vertex_3D_Meta

// .generated.vertex_3d vertex = 1;
inline bool Vertex_3D_Meta::_internal_has_vertex() const {
  return this != internal_default_instance() && _impl_.vertex_ != nullptr;
}
inline bool Vertex_3D_Meta::has_vertex() const {
  return _internal_has_vertex();
}
inline void Vertex_3D_Meta::clear_vertex() {
  if (GetArenaForAllocation() == nullptr && _impl_.vertex_ != nullptr) {
    delete _impl_.vertex_;
  }
  _impl_.vertex_ = nullptr;
}
inline const ::generated::vertex_3d& Vertex_3D_Meta::_internal_vertex() const {
  const ::generated::vertex_3d* p = _impl_.vertex_;
  return p != nullptr ? *p : reinterpret_cast<const ::generated::vertex_3d&>(
      ::generated::_vertex_3d_default_instance_);
}
inline const ::generated::vertex_3d& Vertex_3D_Meta::vertex() const {
  // @@protoc_insertion_point(field_get:generated.Vertex_3D_Meta.vertex)
  return _internal_vertex();
}
inline void Vertex_3D_Meta::unsafe_arena_set_allocated_vertex(
    ::generated::vertex_3d* vertex) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vertex_);
  }
  _impl_.vertex_ = vertex;
  if (vertex) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:generated.Vertex_3D_Meta.vertex)
}
inline ::generated::vertex_3d* Vertex_3D_Meta::release_vertex() {
  
  ::generated::vertex_3d* temp = _impl_.vertex_;
  _impl_.vertex_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::generated::vertex_3d* Vertex_3D_Meta::unsafe_arena_release_vertex() {
  // @@protoc_insertion_point(field_release:generated.Vertex_3D_Meta.vertex)
  
  ::generated::vertex_3d* temp = _impl_.vertex_;
  _impl_.vertex_ = nullptr;
  return temp;
}
inline ::generated::vertex_3d* Vertex_3D_Meta::_internal_mutable_vertex() {
  
  if (_impl_.vertex_ == nullptr) {
    auto* p = CreateMaybeMessage<::generated::vertex_3d>(GetArenaForAllocation());
    _impl_.vertex_ = p;
  }
  return _impl_.vertex_;
}
inline ::generated::vertex_3d* Vertex_3D_Meta::mutable_vertex() {
  ::generated::vertex_3d* _msg = _internal_mutable_vertex();
  // @@protoc_insertion_point(field_mutable:generated.Vertex_3D_Meta.vertex)
  return _msg;
}
inline void Vertex_3D_Meta::set_allocated_vertex(::generated::vertex_3d* vertex) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vertex_;
  }
  if (vertex) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vertex);
    if (message_arena != submessage_arena) {
      vertex = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vertex, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vertex_ = vertex;
  // @@protoc_insertion_point(field_set_allocated:generated.Vertex_3D_Meta.vertex)
}

// optional .generated.Transformation_Meta transformation_meta = 2;
inline bool Vertex_3D_Meta::_internal_has_transformation_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transformation_meta_ != nullptr);
  return value;
}
inline bool Vertex_3D_Meta::has_transformation_meta() const {
  return _internal_has_transformation_meta();
}
inline const ::generated::Transformation_Meta& Vertex_3D_Meta::_internal_transformation_meta() const {
  const ::generated::Transformation_Meta* p = _impl_.transformation_meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::generated::Transformation_Meta&>(
      ::generated::_Transformation_Meta_default_instance_);
}
inline const ::generated::Transformation_Meta& Vertex_3D_Meta::transformation_meta() const {
  // @@protoc_insertion_point(field_get:generated.Vertex_3D_Meta.transformation_meta)
  return _internal_transformation_meta();
}
inline void Vertex_3D_Meta::unsafe_arena_set_allocated_transformation_meta(
    ::generated::Transformation_Meta* transformation_meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transformation_meta_);
  }
  _impl_.transformation_meta_ = transformation_meta;
  if (transformation_meta) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:generated.Vertex_3D_Meta.transformation_meta)
}
inline ::generated::Transformation_Meta* Vertex_3D_Meta::release_transformation_meta() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::generated::Transformation_Meta* temp = _impl_.transformation_meta_;
  _impl_.transformation_meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::generated::Transformation_Meta* Vertex_3D_Meta::unsafe_arena_release_transformation_meta() {
  // @@protoc_insertion_point(field_release:generated.Vertex_3D_Meta.transformation_meta)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::generated::Transformation_Meta* temp = _impl_.transformation_meta_;
  _impl_.transformation_meta_ = nullptr;
  return temp;
}
inline ::generated::Transformation_Meta* Vertex_3D_Meta::_internal_mutable_transformation_meta() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transformation_meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::generated::Transformation_Meta>(GetArenaForAllocation());
    _impl_.transformation_meta_ = p;
  }
  return _impl_.transformation_meta_;
}
inline ::generated::Transformation_Meta* Vertex_3D_Meta::mutable_transformation_meta() {
  ::generated::Transformation_Meta* _msg = _internal_mutable_transformation_meta();
  // @@protoc_insertion_point(field_mutable:generated.Vertex_3D_Meta.transformation_meta)
  return _msg;
}
inline void Vertex_3D_Meta::set_allocated_transformation_meta(::generated::Transformation_Meta* transformation_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transformation_meta_);
  }
  if (transformation_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transformation_meta));
    if (message_arena != submessage_arena) {
      transformation_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transformation_meta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.transformation_meta_ = transformation_meta;
  // @@protoc_insertion_point(field_set_allocated:generated.Vertex_3D_Meta.transformation_meta)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace generated

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_vertex_2eproto
